<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MeatAxe: Finite Fields</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MeatAxe&#160;<span id="projectnumber">2.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group__ff.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Finite Fields</div>  </div>
</div>
<div class="contents">
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>The finite field part of the kernel provides finite field arithmetic and basic operations with vectors and matrices over finite fields. </p>
<p>The kernel cannot operate simultaneously with different finite fields, because there is a global row size and a global field order which must be maintained by the higher layers.</p>
<p>There are two finite field modules available: one for small fields (up to 256) and one for larger fields (up to 2<sup>16</sup>). The finite field module is selected at compile time.</p>
<h2><a class="anchor" id="ff_dt"></a>
Basic data types</h2>
<p>The kernel defines two basic data types: </p>
<dl class="user"><dt><b>FEL</b></dt><dd>represents a single field element </dd></dl>
<dl class="user"><dt><b>PTR</b></dt><dd>is a pointer to a row vector. PTR may be defined as <code>*FEL</code>, but this is not mandatory.</dd></dl>
<p>The kernel also defines two constants: FF_ZERO is the zero element of the current field, and FF_ONE is unit element of the current field. Depending on which kernel you are using, FF_ZERO and FF_ONE need not be constants. They may be defined as variables or even function calls.</p>
<h2><a class="anchor" id="ff_intrep"></a>
Internal data representation</h2>
<dl class="user"><dt><b>'Small' Kernel (q≤256)</b></dt><dd>In the "small" kernel, field elements of GF(q) are represented by the numbers 0,1,...,q-1. The field is defined by its Conway polynomial p(x), a polynomial of degree n over ℤ<sub>p</sub>[x], where q=p<sup>n</sup>. Thus, we have a one-to-one correspondence of field elements a∈GF(q) and polynomials f<sub>a</sub>(x)∈ ℤ<sub>p</sub>[x] of</dd></dl>
<p>degree less than n. By treating ℤ<sub>p</sub> as a subset of ℤ --- actually, on the computer, elements of ℤ<sub>p</sub> are represented by integers --- this is also a polynomial over *ℤ. Now, calculate f_a(p) giving the number of the field element a. It follows that the elements of the prime field are represented by 0,1,...p-1. The number 0 represents the zero element, and 1 represents the unit element.</p>
<dl class="user"><dt><b>'Big' Kernel (q≤65536)</b></dt><dd>The big version stores field elements in 16-bit integers, i.e., each field element occupies two bytes. Non-zero elements are stored as their logarithms with respect to a fixed generator. In particular, the unit element is represented by the integer 0. The zero element is represented by the special value 0xFFFF.</dd></dl>
<p>As a consequence of the different representations of field elements in the small and big version, there are some rules which should be respected by all programs:</p>
<ul>
<li>Never assign numbers to variables of type FEL or pass numbers to functions expecting an argument of type FEL.</li>
<li>Never perform integer arithmetic on variables of type FEL.</li>
<li>Never printf() or scanf() variables of type FEL.</li>
<li>Never use the literals 0 or 1 where the zero and unit element of the field is intended. Instead you should use the FF_ZERO and FF_ONE constants define in |meataxe.h|.</li>
<li>Do not cast an integer to FEL or vice versa. Use <a class="el" href="group__ffrow.html#ga262afe05b2024b456c7e115b3d4cee83" title="Convert integer to field element.">FfFromInt()</a> and <a class="el" href="group__ffrow.html#ga47ad8e40d2cefc9da94992e6fe623f50" title="Convert field element to integer.">FfToInt()</a> instead.</li>
</ul>
<h2><a class="anchor" id="ff_convert"></a>
Converting between finite field elements and integers</h2>
<p>The MeatAxe defines a standard numbering of field elements, i.e., a bijection between GF(q) and the set {0,1,..,q-1}. For prime fields, the mapping is defined by assigning the integer 1 to the unit element of the field. For non-prime fields or forder q=p<sup>n</sup>, each a∈GF(q) is represented -- modulo the ideal generated by the Conway polynomial of degree n -- by a unique polynomial f<sub>a</sub>(x)∈GF(p)[x] with deg(f<sub>a</sub>)&lt;n. Using the standard embedding of GF(p) into ℤ we can consider f<sub>a</sub> as a polynomial over ℤ. Then, the number assigned to a is f<sub>a</sub>(p).</p>
<p>The mapping between GF(q) and {0,1,...,q} is provided by two functions, <a class="el" href="group__ffrow.html#ga262afe05b2024b456c7e115b3d4cee83" title="Convert integer to field element.">FfFromInt()</a> and <a class="el" href="group__ffrow.html#ga47ad8e40d2cefc9da94992e6fe623f50" title="Convert field element to integer.">FfToInt()</a>. Since the actual numeric representation of field elements depends on the kernel, you cannot convert a FEL to an integer simply by type casting.</p>
<h2><a class="anchor" id="ff_embed"></a>
Embedding of subfields</h2>
<p>In the MeatAxe there is a `standard' generator for each finite field. The generator for the field currently in use is available in the FfGen variable. Thus, if a and a' are the MeatAxe generators of GF(q) and GF(q'), respectively, and q'=q<sup>n</sup>, there is a standard embedding of GF(q) into GF(q') defined by $a↪a'<sup>n</sup>. However, field elements which are identified under this embedding are usually not represented by the same number. For this reason there are two functions, <a class="el" href="group__ff.html#gac6fd43143693c70a715879584a58fe13" title="Embed a subfield.">FfEmbed()</a> and <a class="el" href="group__ff.html#ga83c2ea29d3d9b631a893910cd3d852c6" title="Restrict to a subfield.">FfRestrict()</a>, which provide the embedding of subfields into the current field. Note that the MeatAxe is not well suited for calculations involving different fields at the same time because the arithmetic uses lookup tables which are specific to each field</p>
<p>Here is a short example. The following code converts a vector over GF(3) to GF(27). The MeatAxe cannot handle two fields at the same time, so it is necessary to unpack the row over GF(3), change to GF(27) and pack the embedded elements into a new row. </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac" title="A pointer to a row vector.">PTR</a> row1, row2;
 <a class="code" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3" title="A finite field element.">FEL</a> buf[10];
 ...
 <a class="code" href="group__ff.html#gaea2ee97e860179c7e9f6f5e5d9122a1b" title="Set the field order.">FfSetField</a>(10);
 <span class="keywordflow">for</span> (i = 0; i &amp;lt; 10; ++i) buf[i] = <a class="code" href="group__ffrow.html#ga737504e6bf1010575cf78f5c2f8aa0fe" title="!function FfExtract &quot;Extract a mark from a row&quot;">FfExtract</a>(row1,i);
 <a class="code" href="group__ff.html#gaea2ee97e860179c7e9f6f5e5d9122a1b" title="Set the field order.">FfSetField</a>(27);
 <span class="keywordflow">for</span> (i = 0; i &amp;lt; 10; ++i) <a class="code" href="group__ffrow.html#gaec649872c5347b324a0a1276b99ab375" title="Insert a mark into a row This function inserts the field element mark at position col into row...">FfInsert</a>(row2,i,<a class="code" href="group__ff.html#gac6fd43143693c70a715879584a58fe13" title="Embed a subfield.">FfEmbed</a>(buf[i],3));
</pre></div> <table class="memberdecls">
<tr><td colspan="2"><h2><a name="groups"></a>
Modules</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ffio.html">File I/O</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Binary data files contain a sequence of objects. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7629adc7ffcba808ca0037fc6f25c95e"></a><!-- doxytag: member="ff::FF_ZERO" ref="ga7629adc7ffcba808ca0037fc6f25c95e" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#ga7629adc7ffcba808ca0037fc6f25c95e">FF_ZERO</a>&#160;&#160;&#160;((<a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a>)0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The zero field element. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1ee2d22ddc96bf7c12241e9fe23c4d76"></a><!-- doxytag: member="ff::FF_ONE" ref="ga1ee2d22ddc96bf7c12241e9fe23c4d76" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#ga1ee2d22ddc96bf7c12241e9fe23c4d76">FF_ONE</a>&#160;&#160;&#160;((<a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a>)1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The unit element. <br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7aa199c0a6bba46562519780595ee2f3"></a><!-- doxytag: member="ff::FEL" ref="ga7aa199c0a6bba46562519780595ee2f3" args="" -->
typedef unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A finite field element. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2dc160f7cd3b7190becfc9eab62b58ac"></a><!-- doxytag: member="ff::PTR" ref="ga2dc160f7cd3b7190becfc9eab62b58ac" args="" -->
typedef <a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to a row vector. <br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#gaea2ee97e860179c7e9f6f5e5d9122a1b">FfSetField</a> (int field)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the field order.  <a href="#gaea2ee97e860179c7e9f6f5e5d9122a1b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#gad55c74480f586ce5be5f466b354c5092">FfSetNoc</a> (int noc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the row length.  <a href="#gad55c74480f586ce5be5f466b354c5092"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#ga532108a76ee8e0bb0b1b668e625f1226">FfRowSize</a> (int noc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate row size.  <a href="#ga532108a76ee8e0bb0b1b668e625f1226"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#ga1a0113d077e98ea763ff39cdf326b3ad">FfTrueRowSize</a> (int noc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of used bytes in a row.  <a href="#ga1a0113d077e98ea763ff39cdf326b3ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#gac6fd43143693c70a715879584a58fe13">FfEmbed</a> (<a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a> a, int subfield)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Embed a subfield.  <a href="#gac6fd43143693c70a715879584a58fe13"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#ga83c2ea29d3d9b631a893910cd3d852c6">FfRestrict</a> (<a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a> a, int subfield)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Restrict to a subfield.  <a href="#ga83c2ea29d3d9b631a893910cd3d852c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#gababccce21c8779b9cbb85a4a071163a5">FfAdd</a> (<a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a> a, <a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a> b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finite field addition.  <a href="#gababccce21c8779b9cbb85a4a071163a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#gaeaabe2ff3bc369785750900f37103f74">FfSub</a> (<a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a> a, <a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a> b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finite field subtraction.  <a href="#gaeaabe2ff3bc369785750900f37103f74"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#ga5868d73d7e8107c5215fc74b9d3e8aaf">FfMul</a> (<a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a> a, <a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a> b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finite field multiplication.  <a href="#ga5868d73d7e8107c5215fc74b9d3e8aaf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#ga6036fe98ad21fe6266893147267548fa">FfDiv</a> (<a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a> a, <a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a> b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finite field division.  <a href="#ga6036fe98ad21fe6266893147267548fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#ga7e8807a80342eacac9a0ae237d52920d">FfNeg</a> (<a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a> a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finite field negative.  <a href="#ga7e8807a80342eacac9a0ae237d52920d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#gaf0f05703fd212ede9b1dd500f7acf39d">FfInv</a> (<a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a> a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finite field inversion.  <a href="#gaf0f05703fd212ede9b1dd500f7acf39d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#ga2a886cd816b5adb75fd8a01e388e4082">FfAddMulRow</a> (<a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> dest, <a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> src, <a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a> f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a multiple of a row.  <a href="#ga2a886cd816b5adb75fd8a01e388e4082"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#ga1afd49bf564f21b0b980ddc2cbf5434e">FfAddRow</a> (<a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> dest, <a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> src)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two rows.  <a href="#ga1afd49bf564f21b0b980ddc2cbf5434e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#ga909e3cd284a59c57f69debbea029b1ea">FfAddRowPartial</a> (<a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> dest, <a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> src, int first, int len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a part two rows.  <a href="#ga909e3cd284a59c57f69debbea029b1ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#ga7e2c19aab34a4094460616af8407823c">FfAlloc</a> (int nor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory and initialize This function allocates a block of memory for a vector (if <em>nrows</em> is 1) or a matrix.  <a href="#ga7e2c19aab34a4094460616af8407823c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#ga59ce80c8d0a96a65964e9e279765bda1">FfCmpRows</a> (<a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> p1, <a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> p2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two Rows.  <a href="#ga59ce80c8d0a96a65964e9e279765bda1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#gad9ea8b12c32280479b1bd4fbd755ec1a">FfCleanRow</a> (<a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> row, <a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> matrix, int nor, const int *piv)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean Row.  <a href="#gad9ea8b12c32280479b1bd4fbd755ec1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#gaa9c679a78dd6c0298e4c4ca76b2b4b67">FfCleanRow2</a> (<a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> row, <a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> mat, int nor, const int *piv, <a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> row2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean Row and Record Operations.  <a href="#gaa9c679a78dd6c0298e4c4ca76b2b4b67"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#ga96994579c96b48d9cd669217271a1693">FfCleanRowAndRepeat</a> (<a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> row, <a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> mat, int nor, const int *piv, <a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> row2, <a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> mat2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean Row and Repeat Operations.  <a href="#ga96994579c96b48d9cd669217271a1693"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#gaa9ad04522cf1db9f879baa892e2075f0">FfCopyRow</a> (<a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> dest, <a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> src)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a row.  <a href="#gaa9ad04522cf1db9f879baa892e2075f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#ga737504e6bf1010575cf78f5c2f8aa0fe">FfExtract</a> (<a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> row, int col)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">!function FfExtract "Extract a mark from a row"  <a href="#ga737504e6bf1010575cf78f5c2f8aa0fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#gaea551734d2fbc8c28659f58a18a0eafb">FfExtractColumn</a> (<a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> mat, int nor, int col, <a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">!section kernel.ff.row Extract one column of a matrix.  <a href="#gaea551734d2fbc8c28659f58a18a0eafb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#ga71b8e6f4640a6df2f8a41d250ad743ae">FfFindPivot</a> (<a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> row, <a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a> *mark)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find pivot column.  <a href="#ga71b8e6f4640a6df2f8a41d250ad743ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#ga86b1f3891f4044efab3479336b2f13e3">FfFree</a> (<a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory.  <a href="#ga86b1f3891f4044efab3479336b2f13e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#ga262afe05b2024b456c7e115b3d4cee83">FfFromInt</a> (int l)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert integer to field element.  <a href="#ga262afe05b2024b456c7e115b3d4cee83"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#gaafbdb3f0a67651eeae1b9cacd3200be6">FfGetPtr</a> (<a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> base, int row)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get row pointer.  <a href="#gaafbdb3f0a67651eeae1b9cacd3200be6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#gaec649872c5347b324a0a1276b99ab375">FfInsert</a> (<a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> row, int col, <a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a> mark)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a mark into a row This function inserts the field element <em>mark</em> at position <em>col</em> into <em>row</em>.  <a href="#gaec649872c5347b324a0a1276b99ab375"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#ga71d62ce3689f54e934b90bad709d8b82">FfMulRow</a> (<a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> row, <a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a> mark)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a row by a coefficient.  <a href="#ga71d62ce3689f54e934b90bad709d8b82"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#gaa6eef0641b9d2f9469bdce14e130f99c">FfReadHeader</a> (const char *name, int *fld, int *nor, int *noc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Open File and Read Header.  <a href="#gaa6eef0641b9d2f9469bdce14e130f99c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#ga39f5d066a7a11ec4718d1ad56e155b4c">FfReadRows</a> (FILE *f, <a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> buf, int n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Rows This function reads 1 or more rows from a file.  <a href="#ga39f5d066a7a11ec4718d1ad56e155b4c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#ga4991816cc92dbc53c8945825b88a86c7">FfScalarProduct</a> (<a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> a, <a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar Product of Two Vectors.  <a href="#ga4991816cc92dbc53c8945825b88a86c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#gacb22ee413f32e58f4a2f2bb74698fad8">FfSeekRow</a> (FILE *f, int pos)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Move to a Row.  <a href="#gacb22ee413f32e58f4a2f2bb74698fad8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#ga80a63e88c5e305f287388c9c29b70360">FfStepPtr</a> (<a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> *x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance to next row.  <a href="#ga80a63e88c5e305f287388c9c29b70360"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#gaa859d951af7288abe8e4c1f9b980406a">FfSwapRows</a> (<a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> dest, <a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> src)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchange two rows This function exchanges the contents of two rows.  <a href="#gaa859d951af7288abe8e4c1f9b980406a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#gabc0c850a5c74041f839332bab7f14e0a">FfToGap</a> (<a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a> f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to GAP format.  <a href="#gabc0c850a5c74041f839332bab7f14e0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#ga47ad8e40d2cefc9da94992e6fe623f50">FfToInt</a> (<a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a> f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert field element to integer.  <a href="#ga47ad8e40d2cefc9da94992e6fe623f50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#ga2a2041dc484908929f4803e2e8b2939c">FfWriteHeader</a> (const char *name, int fld, int nor, int noc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Open File and Write Header.  <a href="#ga2a2041dc484908929f4803e2e8b2939c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#gac0425c9851a076ec59771ff409cf90fd">FfWriteRows</a> (FILE *f, <a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> buf, int n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write rows This function writes 1 or more rows to a file.  <a href="#gac0425c9851a076ec59771ff409cf90fd"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#ga271e08c9c124d5463151e7ea457f72f8">FfCurrentRowSize</a> = (size_t) -1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Row size.  <a href="#ga271e08c9c124d5463151e7ea457f72f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#ga09f7794098a89b94fe64ab364c90601f">FfCurrentRowSizeIo</a> = -1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">I/O row size.  <a href="#ga09f7794098a89b94fe64ab364c90601f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#ga29c9610e1e3f82431f9fde08d50b33d2">FfOrder</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Current field order.  <a href="#ga29c9610e1e3f82431f9fde08d50b33d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#gad698cd18b748f79406cf20ea6dc64912">FfChar</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Current characteristic.  <a href="#gad698cd18b748f79406cf20ea6dc64912"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#gafbc60cf678ca46b8a235048d0fd204ea">FfGen</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generator.  <a href="#gafbc60cf678ca46b8a235048d0fd204ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#gaf8ebb85f6f53229ae4a43df827ddd0e8">FfNoc</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of columns for row ops.  <a href="#gaf8ebb85f6f53229ae4a43df827ddd0e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#ga271e08c9c124d5463151e7ea457f72f8">FfCurrentRowSize</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Row size.  <a href="#ga271e08c9c124d5463151e7ea457f72f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#ga29c9610e1e3f82431f9fde08d50b33d2">FfOrder</a> = -1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Field order.  <a href="#ga29c9610e1e3f82431f9fde08d50b33d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#gafbc60cf678ca46b8a235048d0fd204ea">FfGen</a> = 0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Field generator.  <a href="#gafbc60cf678ca46b8a235048d0fd204ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff.html#gaf8ebb85f6f53229ae4a43df827ddd0e8">FfNoc</a> = 0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Current row size.  <a href="#gaf8ebb85f6f53229ae4a43df827ddd0e8"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gababccce21c8779b9cbb85a4a071163a5"></a><!-- doxytag: member="meataxe.h::FfAdd" ref="gababccce21c8779b9cbb85a4a071163a5" args="(FEL a, FEL b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FfAdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finite field addition. </p>
<p>This function returns the sum of two field elements. Before calling <a class="el" href="group__ff.html#gababccce21c8779b9cbb85a4a071163a5" title="Finite field addition.">FfAdd()</a>, the field must have been selected with <a class="el" href="group__ff.html#gaea2ee97e860179c7e9f6f5e5d9122a1b" title="Set the field order.">FfSetField()</a>. The arguments are not checked. If either argument is not in the allowed range the result is undefined and the program may crash. <a class="el" href="group__ff.html#gababccce21c8779b9cbb85a4a071163a5" title="Finite field addition.">FfAdd()</a> may be implemented as a macro. In this case, it is guaranteed that both arguments are evaluated exactly once. </p>

</div>
</div>
<a class="anchor" id="ga2a886cd816b5adb75fd8a01e388e4082"></a><!-- doxytag: member="meataxe.h::FfAddMulRow" ref="ga2a886cd816b5adb75fd8a01e388e4082" args="(PTR dest, PTR src, FEL f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FfAddMulRow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a multiple of a row. </p>
<p>This function adds a multiple of <em>src</em> to <em>dest</em>. </p>

</div>
</div>
<a class="anchor" id="ga1afd49bf564f21b0b980ddc2cbf5434e"></a><!-- doxytag: member="meataxe.h::FfAddRow" ref="ga1afd49bf564f21b0b980ddc2cbf5434e" args="(PTR dest, PTR src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> FfAddRow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add two rows. </p>
<p>This function adds src to dest. Field order and row size must have been set before. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The row to add to. </td></tr>
    <tr><td class="paramname">src</td><td>The row to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Always returns dest. </dd></dl>

</div>
</div>
<a class="anchor" id="ga909e3cd284a59c57f69debbea029b1ea"></a><!-- doxytag: member="meataxe.h::FfAddRowPartial" ref="ga909e3cd284a59c57f69debbea029b1ea" args="(PTR dest, PTR src, int first, int len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> FfAddRowPartial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a part two rows. </p>
<p>This works like <a class="el" href="group__ffrow.html#ga1afd49bf564f21b0b980ddc2cbf5434e" title="Add two rows.">FfAddRow()</a>, but the operation is performed only on a given range of columns. Note that the working range is not specified as column indexes but in units of long integers! </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The row to add to. </td></tr>
    <tr><td class="paramname">src</td><td>The row to add. </td></tr>
    <tr><td class="paramname">first</td><td>Number of long integers to skip. </td></tr>
    <tr><td class="paramname">len</td><td>Number of long integers to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Always returns dest. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7e2c19aab34a4094460616af8407823c"></a><!-- doxytag: member="meataxe.h::FfAlloc" ref="ga7e2c19aab34a4094460616af8407823c" args="(int nor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> FfAlloc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrows</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate memory and initialize This function allocates a block of memory for a vector (if <em>nrows</em> is 1) or a matrix. </p>
<p>Memory is initialized to zero. Field order and row size must have been set with <a class="el" href="group__ff.html#gaea2ee97e860179c7e9f6f5e5d9122a1b" title="Set the field order.">FfSetField()</a> and <a class="el" href="group__ff.html#gad55c74480f586ce5be5f466b354c5092" title="Set the row length.">FfSetNoc()</a>, respectively. <em>nrows</em> may be zero zero, i which case the functin returns a memory block of size zero which must be freed using <a class="el" href="group__ff.html#ga86b1f3891f4044efab3479336b2f13e3" title="Free memory.">FfFree()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">nrows</td><td>Number of rows. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the memory block or NULL on error. </dd></dl>

</div>
</div>
<a class="anchor" id="gad9ea8b12c32280479b1bd4fbd755ec1a"></a><!-- doxytag: member="meataxe.h::FfCleanRow" ref="gad9ea8b12c32280479b1bd4fbd755ec1a" args="(PTR row, PTR matrix, int nor, const int *piv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FfCleanRow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>piv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clean Row. </p>
<p>This function performs a Gaussian elimination, i.e., it adds suitable multiples of the rows of <em>matrix</em> to <em>row</em> such that all pivot positions are zero. <em>piv</em> is the pivot table for <em>matrix</em>. As usual, all indexes are 0-based, i.e., <code>piv[0]</code> is the pivot column of the first row, and for a unit matrix we have <code>piv[0]==0</code>. The field and row size must have been set before calling this function. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row to be cleaned. </td></tr>
    <tr><td class="paramname">matrix</td><td>Pointer to the matrix. </td></tr>
    <tr><td class="paramname">nor</td><td>Number of rows of the matrix. </td></tr>
    <tr><td class="paramname">piv</td><td>The pivot table. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa9c679a78dd6c0298e4c4ca76b2b4b67"></a><!-- doxytag: member="meataxe.h::FfCleanRow2" ref="gaa9c679a78dd6c0298e4c4ca76b2b4b67" args="(PTR row, PTR mat, int nor, const int *piv, PTR row2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FfCleanRow2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>piv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>row2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clean Row and Record Operations. </p>
<p>This function works like <a class="el" href="group__ff.html#gad9ea8b12c32280479b1bd4fbd755ec1a" title="Clean Row.">FfCleanRow()</a>, but it stores a record of the operations performed in <em>row2</em>. <em>row2</em> must be a row of at least <em>nor</em> entries. On return, <em>row2</em> contains the coefficients by which the rows of <em>mat</em> were multiplied and then subtracted from <em>row</em>. Before calling FfCleanRow2(), the caller must initialize <em>row2</em> to zero. Otherwise the results are undefined. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Pointer to row to be cleaned. </td></tr>
    <tr><td class="paramname">mat</td><td>Matrix to clean with. </td></tr>
    <tr><td class="paramname">nor</td><td>Number of rows. </td></tr>
    <tr><td class="paramname">piv</td><td>Pivot table for <em>matrix</em>. </td></tr>
    <tr><td class="paramname">row2</td><td>Pointer to row where the operations are recorded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Always 0. </dd></dl>

</div>
</div>
<a class="anchor" id="ga96994579c96b48d9cd669217271a1693"></a><!-- doxytag: member="meataxe.h::FfCleanRowAndRepeat" ref="ga96994579c96b48d9cd669217271a1693" args="(PTR row, PTR mat, int nor, const int *piv, PTR row2, PTR mat2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FfCleanRowAndRepeat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>piv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>row2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>mat2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clean Row and Repeat Operations. </p>
<p>This function works like <a class="el" href="group__ff.html#gad9ea8b12c32280479b1bd4fbd755ec1a" title="Clean Row.">FfCleanRow()</a>, but repeats all operations on a second row/matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Pointer to row to be cleaned. </td></tr>
    <tr><td class="paramname">mat</td><td>Matrix to clean with. </td></tr>
    <tr><td class="paramname">nor</td><td>Number of rows. </td></tr>
    <tr><td class="paramname">piv</td><td>Pivot table for <em>mat</em>. </td></tr>
    <tr><td class="paramname">row2</td><td>Pointer to the second row to be cleaned. </td></tr>
    <tr><td class="paramname">mat2</td><td>Matrix to the second matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Always 0. </dd></dl>

</div>
</div>
<a class="anchor" id="ga59ce80c8d0a96a65964e9e279765bda1"></a><!-- doxytag: member="meataxe.h::FfCmpRows" ref="ga59ce80c8d0a96a65964e9e279765bda1" args="(PTR p1, PTR p2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FfCmpRows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compare two Rows. </p>
<p>This function compares two row vectors. As with all row operations, the row length must have been set before with <a class="el" href="group__ff.html#gad55c74480f586ce5be5f466b354c5092" title="Set the row length.">FfSetNoc()</a>. The return value is negative if the first row is "less" than the second row, and it is positive if the first row is "greater" than the second row. However, the ordering defined by <a class="el" href="group__ff.html#ga59ce80c8d0a96a65964e9e279765bda1" title="Compare two Rows.">FfCmpRows()</a> depends on the internal representation of finite field elements and can differ between dirrerent kernels or between different hardware architectures. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>Pointer to the first matrix. </td></tr>
    <tr><td class="paramname">p2</td><td>Pointer to the second matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The function returns 0 if the two rows are identical. Otherwise the return value is different from 0. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa9ad04522cf1db9f879baa892e2075f0"></a><!-- doxytag: member="meataxe.h::FfCopyRow" ref="gaa9ad04522cf1db9f879baa892e2075f0" args="(PTR dest, PTR src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FfCopyRow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy a row. </p>
<p>This function copies the contents of one row to another row. As with all row operations, the row length must have been set before with |FfSetNoc()|. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Pointer to the destination. </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to the source. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6036fe98ad21fe6266893147267548fa"></a><!-- doxytag: member="meataxe.h::FfDiv" ref="ga6036fe98ad21fe6266893147267548fa" args="(FEL a, FEL b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FfDiv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finite field division. </p>
<p>This function returns the quotient of two field elements. Before calling <a class="el" href="group__ff.html#ga6036fe98ad21fe6266893147267548fa" title="Finite field division.">FfDiv()</a>, the field must have been selected with <a class="el" href="group__ff.html#gaea2ee97e860179c7e9f6f5e5d9122a1b" title="Set the field order.">FfSetField()</a>. The arguments are not checked. If either argument is not in the allowed range or if the denominator is zero, the result is undefined and the program may crash. <a class="el" href="group__ff.html#ga6036fe98ad21fe6266893147267548fa" title="Finite field division.">FfDiv()</a> may be implemented as a macro. In this case, it is guaranteed that both arguments are evaluated exactly once. </p>

</div>
</div>
<a class="anchor" id="gac6fd43143693c70a715879584a58fe13"></a><!-- doxytag: member="kernel&#45;0.c::FfEmbed" ref="gac6fd43143693c70a715879584a58fe13" args="(FEL a, int subfield)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a> FfEmbed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subfield</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Embed a subfield. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Element of the subfield field. </td></tr>
    <tr><td class="paramname">subfield</td><td>Subfield order. Must be a divisor of the current field order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><em>a</em>, embedded into the current field. </dd></dl>

</div>
</div>
<a class="anchor" id="ga737504e6bf1010575cf78f5c2f8aa0fe"></a><!-- doxytag: member="meataxe.h::FfExtract" ref="ga737504e6bf1010575cf78f5c2f8aa0fe" args="(PTR row, int col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a> FfExtract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>!function FfExtract "Extract a mark from a row" </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Pointer to the row. </td></tr>
    <tr><td class="paramname">col</td><td>Index of mark to extract (0-based). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>|col|-th entry of |row|. !description This function returns the entry at position |col| of a row. Note that column indexes start with 0, i.e., |FfExtract(row,0)| returns the first entry of a row. Like |FfInsert()|, this function does not depend on the current row size. Reading beyond the end of a row will probably not produce an error, but the result is undefined. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__ff.html#gaec649872c5347b324a0a1276b99ab375" title="Insert a mark into a row This function inserts the field element mark at position col into row...">FfInsert</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaea551734d2fbc8c28659f58a18a0eafb"></a><!-- doxytag: member="meataxe.h::FfExtractColumn" ref="gaea551734d2fbc8c28659f58a18a0eafb" args="(PTR mat, int nor, int col, PTR result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FfExtractColumn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>!section kernel.ff.row Extract one column of a matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Pointer to the matrix. </td></tr>
    <tr><td class="paramname">nor</td><td>Number of rows in matrix. </td></tr>
    <tr><td class="paramname">col</td><td>Column to extract (starting with 1). </td></tr>
    <tr><td class="paramname">result</td><td>Pointer to buffer for the extracted column. !description This function extracts one column out of a matrix and stores it as a row vector in |result|. The number of columns of the matrix must have been set with |FfSetNoc()|. |nor| is the number of rows in the matrix. The result is a row with |nor| entries, i.e., the length of |result| must be at least |nor|. |mat| and |result| must not overlap, or the result is undefined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga71b8e6f4640a6df2f8a41d250ad743ae"></a><!-- doxytag: member="meataxe.h::FfFindPivot" ref="ga71b8e6f4640a6df2f8a41d250ad743ae" args="(PTR row, FEL *mark)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FfFindPivot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a> *&#160;</td>
          <td class="paramname"><em>mark</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find pivot column. </p>
<p>This function scans the vector <em>row</em> and finds the first non-zero mark. The mark is stored into <code>*mark</code> and its position (counting from 0) is returned. If the whole vector is zero, FfFindPivot() returns -1 and leaves <code>*mark</code> unchanged. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Pointer to the row. </td></tr>
    <tr><td class="paramname">mark</td><td>Buffer for pivot element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Index of the first non-zero entry in <em>row</em> or -1 if all entries are zero. </dd></dl>

</div>
</div>
<a class="anchor" id="ga86b1f3891f4044efab3479336b2f13e3"></a><!-- doxytag: member="meataxe.h::FfFree" ref="ga86b1f3891f4044efab3479336b2f13e3" args="(PTR x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FfFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free memory. </p>
<p>This function frees a block of memory that has been allocated with <a class="el" href="group__ff.html#ga7e2c19aab34a4094460616af8407823c" title="Allocate memory and initialize This function allocates a block of memory for a vector (if nrows is 1)...">FfAlloc()</a> before. If the argument is 0, FfFree() does nothing. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Pointer to memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga262afe05b2024b456c7e115b3d4cee83"></a><!-- doxytag: member="meataxe.h::FfFromInt" ref="ga262afe05b2024b456c7e115b3d4cee83" args="(int l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a> FfFromInt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert integer to field element. </p>
<p>This function converts an integer to a field element using the same mapping as explained under <a class="el" href="group__ffrow.html#ga47ad8e40d2cefc9da94992e6fe623f50" title="Convert field element to integer.">FfToInt()</a>. Both functions are inverse in the sense that the expression <code>f == FfFromInt(FfToInt(f))</code> is always true for valid field elements. <a class="el" href="group__ffrow.html#ga262afe05b2024b456c7e115b3d4cee83" title="Convert integer to field element.">FfFromInt()</a> should be used whenever field elements are to be read with scanf(). </p>

</div>
</div>
<a class="anchor" id="gaafbdb3f0a67651eeae1b9cacd3200be6"></a><!-- doxytag: member="meataxe.h::FfGetPtr" ref="gaafbdb3f0a67651eeae1b9cacd3200be6" args="(PTR base, int row)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> FfGetPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get row pointer. </p>
<p>This function returns a pointer to the |nor|-th row of a matrix, assuming the current row size. |base| must be a pointer to the beginning of a row, but this need not be the first row of the matrix. For example, the following code steps through the odd rows of a matrix: </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac" title="A pointer to a row vector.">PTR</a> r = matrix;
 <span class="keywordtype">int</span> i;
 <span class="keywordflow">for</span> (i = 1; i &lt; nrows; i += 2)
 {
    r = <a class="code" href="group__ff.html#gaafbdb3f0a67651eeae1b9cacd3200be6" title="Get row pointer.">FfGetPtr</a>(r,2);
    ...
 }
</pre></div><p> Note: The function does not check if the resulting pointer is still inside the matrix. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__ff.html#ga80a63e88c5e305f287388c9c29b70360" title="Advance to next row.">FfStepPtr()</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to the first row of the matrix. </td></tr>
    <tr><td class="paramname">row</td><td>Row index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaec649872c5347b324a0a1276b99ab375"></a><!-- doxytag: member="meataxe.h::FfInsert" ref="gaec649872c5347b324a0a1276b99ab375" args="(PTR row, int col, FEL mark)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FfInsert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a>&#160;</td>
          <td class="paramname"><em>mark</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert a mark into a row This function inserts the field element <em>mark</em> at position <em>col</em> into <em>row</em>. </p>
<p>Column indexes start with 0. Before this function can be used, the field must be selected with <a class="el" href="group__ff.html#gaea2ee97e860179c7e9f6f5e5d9122a1b" title="Set the field order.">FfSetField()</a>. FfInsert() does not need the row size beeing set correctly. For example, if you are working with rows of different size, you do not have to call <a class="el" href="group__ff.html#gad55c74480f586ce5be5f466b354c5092" title="Set the row length.">FfSetNoc()</a> prior to each FfInsert(). On the other hand, there is no protection against writing beyond the end of a row.</p>
<p>If the MeatAxe is compiled with the DEBUG option FfInsert() checks that <em>mark</em> is a valid field element and <em>col</em> is not negative. If also the PARANOID option was in effect during compilation, FfInsert() also checks if <em>col</em> is less than or equal to the current row size. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Pointer to the row. </td></tr>
    <tr><td class="paramname">col</td><td>Insert position (0-based). </td></tr>
    <tr><td class="paramname">mark</td><td>Value to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf0f05703fd212ede9b1dd500f7acf39d"></a><!-- doxytag: member="meataxe.h::FfInv" ref="gaf0f05703fd212ede9b1dd500f7acf39d" args="(FEL a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FfInv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a>&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finite field inversion. </p>
<p>This function returns the multiplicative inverse a field element. Before calling <a class="el" href="group__ff.html#gaf0f05703fd212ede9b1dd500f7acf39d" title="Finite field inversion.">FfInv()</a>, the field must have been selected with <a class="el" href="group__ff.html#gaea2ee97e860179c7e9f6f5e5d9122a1b" title="Set the field order.">FfSetField()</a>. The argument is not checked. If you pass an invalid value or zero, the result is undefined and the program may crash. <a class="el" href="group__ff.html#gaf0f05703fd212ede9b1dd500f7acf39d" title="Finite field inversion.">FfInv()</a> may be implemented as a macro. In this case, it is guaranteed that the argument is evaluated exactly once. </p>

</div>
</div>
<a class="anchor" id="ga5868d73d7e8107c5215fc74b9d3e8aaf"></a><!-- doxytag: member="meataxe.h::FfMul" ref="ga5868d73d7e8107c5215fc74b9d3e8aaf" args="(FEL a, FEL b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FfMul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finite field multiplication. </p>
<p>This function returns the product of two field elements. Before calling <a class="el" href="group__ff.html#ga5868d73d7e8107c5215fc74b9d3e8aaf" title="Finite field multiplication.">FfMul()</a>, the field must have been selected with <a class="el" href="group__ff.html#gaea2ee97e860179c7e9f6f5e5d9122a1b" title="Set the field order.">FfSetField()</a>. The arguments are not checked. If either argument is not in the allowed range the result is undefined and the program may crash. <a class="el" href="group__ff.html#ga5868d73d7e8107c5215fc74b9d3e8aaf" title="Finite field multiplication.">FfMul()</a> may be implemented as a macro. In this case, it is guaranteed that both arguments are evaluated exactly once. </p>

</div>
</div>
<a class="anchor" id="ga71d62ce3689f54e934b90bad709d8b82"></a><!-- doxytag: member="meataxe.h::FfMulRow" ref="ga71d62ce3689f54e934b90bad709d8b82" args="(PTR row, FEL mark)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FfMulRow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a>&#160;</td>
          <td class="paramname"><em>mark</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiply a row by a coefficient. </p>
<p>This function multiplies each element of <em>row</em> by <em>mark</em>. The row size and field order must have been set before. Multiplying a row with zero (FF_ZERO) initializes all elements to zero and is permitted even if <em>row</em> points into uninitialized memory. </p>

</div>
</div>
<a class="anchor" id="ga7e8807a80342eacac9a0ae237d52920d"></a><!-- doxytag: member="meataxe.h::FfNeg" ref="ga7e8807a80342eacac9a0ae237d52920d" args="(FEL a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FfNeg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a>&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finite field negative. </p>
<p>This function returns the additive inverse a field element. Before calling <a class="el" href="group__ff.html#gaf0f05703fd212ede9b1dd500f7acf39d" title="Finite field inversion.">FfInv()</a>, the field must have been selected with <a class="el" href="group__ff.html#gaea2ee97e860179c7e9f6f5e5d9122a1b" title="Set the field order.">FfSetField()</a>. The argument is not checked. If you pass an invalid value, the result is undefined and the program may crash. <a class="el" href="group__ff.html#ga7e8807a80342eacac9a0ae237d52920d" title="Finite field negative.">FfNeg()</a> may be implemented as a macro. In this case, it is guaranteed that the argument is evaluated exactly once. </p>

</div>
</div>
<a class="anchor" id="gaa6eef0641b9d2f9469bdce14e130f99c"></a><!-- doxytag: member="meataxe.h::FfReadHeader" ref="gaa6eef0641b9d2f9469bdce14e130f99c" args="(const char *name, int *fld, int *nor, int *noc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FILE* FfReadHeader </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>noc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open File and Read Header. </p>
<p>This function opens a data file for input and reads the file header (3 integers). The exact meaning of the header values depends on the file type. For a matrix they are field order, number of rows and number of columns. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>File name. </td></tr>
    <tr><td class="paramname">field</td><td>Pointer to buffer for first header entry (usually the field order). </td></tr>
    <tr><td class="paramname">nor</td><td>Pointer to buffer for second header entry (usually the number of rows). </td></tr>
    <tr><td class="paramname">noc</td><td>Pointer to buffer for third header entry (usually the number of columns). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to open file, or 0 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga39f5d066a7a11ec4718d1ad56e155b4c"></a><!-- doxytag: member="meataxe.h::FfReadRows" ref="ga39f5d066a7a11ec4718d1ad56e155b4c" args="(FILE *f, PTR buf, int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FfReadRows </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read Rows This function reads 1 or more rows from a file. </p>
<p>The row size must have been set before. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Pointer to File. </td></tr>
    <tr><td class="paramname">buf</td><td>Pointer to data buffer. </td></tr>
    <tr><td class="paramname">n</td><td>Number of rows to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of rows that were actually read, or -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga83c2ea29d3d9b631a893910cd3d852c6"></a><!-- doxytag: member="kernel&#45;0.c::FfRestrict" ref="ga83c2ea29d3d9b631a893910cd3d852c6" args="(FEL a, int subfield)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a> FfRestrict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subfield</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Restrict to a subfield. </p>
<p>This function restricts a field element from the current field to a subfield. The return value represents the same element as <em>a</em> but with respect to the subfield. In general, the element has a different integer representation in the subfield. Consequently, you cannot use the return value for field arithmetic until you change to the subfield with Of course, the argument must be an element of the subfield. Otherwise the result is undefined. <code>FfSetField(subfield)</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Element of the current field. </td></tr>
    <tr><td class="paramname">subfield</td><td>Subfield order. Must be a divisor of the current field order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga532108a76ee8e0bb0b1b668e625f1226"></a><!-- doxytag: member="kernel&#45;0.c::FfRowSize" ref="ga532108a76ee8e0bb0b1b668e625f1226" args="(int noc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t FfRowSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>noc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate row size. </p>
<p>Returns the number of bytes occupied in memory by a row of <em>noc</em> Elements. The row size is always a multiple of <code>sizeof(long)</code>. Depending on the number of columns there may be unused padding bytes at the end of the row. </p>

</div>
</div>
<a class="anchor" id="ga4991816cc92dbc53c8945825b88a86c7"></a><!-- doxytag: member="meataxe.h::FfScalarProduct" ref="ga4991816cc92dbc53c8945825b88a86c7" args="(PTR a, PTR b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a> FfScalarProduct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scalar Product of Two Vectors. </p>
<p>Given two vectors <img class="formulaInl" alt="$a=(a_i)$" src="form_0.png"/> and <img class="formulaInl" alt="$b=(b_i)$" src="form_1.png"/>, this function calculates the scalar product <img class="formulaInl" alt="$p=\sum_ia_ib_i$" src="form_2.png"/>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first vector. </td></tr>
    <tr><td class="paramname">b</td><td>The second vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Scalar product of the two vectors. </dd></dl>

</div>
</div>
<a class="anchor" id="gacb22ee413f32e58f4a2f2bb74698fad8"></a><!-- doxytag: member="meataxe.h::FfSeekRow" ref="gacb22ee413f32e58f4a2f2bb74698fad8" args="(FILE *f, int pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FfSeekRow </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Move to a Row. </p>
<p>This function sets the read/write pointer of file <em>f</em> to position <em>pos</em>. I.e., the next <a class="el" href="group__ffio.html#ga39f5d066a7a11ec4718d1ad56e155b4c" title="Read Rows This function reads 1 or more rows from a file.">FfReadRows()</a> or <a class="el" href="group__ffio.html#gac0425c9851a076ec59771ff409cf90fd" title="Write rows This function writes 1 or more rows to a file.">FfWriteRows()</a> will start at the specified row. Note that row numbers start with 0. If <em>pos</em> is different from 0, the row size must have been set before with <a class="el" href="group__ff.html#gad55c74480f586ce5be5f466b354c5092" title="Set the row length.">FfSetNoc()</a>.</p>
<p>You should always use <a class="el" href="group__ffio.html#gacb22ee413f32e58f4a2f2bb74698fad8" title="Move to a Row.">FfSeekRow()</a> rather than fseek() because <a class="el" href="group__ffio.html#gacb22ee413f32e58f4a2f2bb74698fad8" title="Move to a Row.">FfSeekRow()</a> knows about MeatAxe file headers and adjusts the file pointer appropriately. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Pointer to File. </td></tr>
    <tr><td class="paramname">pos</td><td>Row number (0-based). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="gaea2ee97e860179c7e9f6f5e5d9122a1b"></a><!-- doxytag: member="kernel&#45;0.c::FfSetField" ref="gaea2ee97e860179c7e9f6f5e5d9122a1b" args="(int field)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FfSetField </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>field</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the field order. </p>
<p>This function sets the current field to GF(<em>field</em>) and initializes the field arithmetic. Most kernel functions require that a field has been selected before they are used. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">field</td><td>Field order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gad55c74480f586ce5be5f466b354c5092"></a><!-- doxytag: member="kernel&#45;0.c::FfSetNoc" ref="gad55c74480f586ce5be5f466b354c5092" args="(int noc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FfSetNoc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>noc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the row length. </p>
<p>This function sets the current row size, which is used for low-level row operations such as <a class="el" href="group__ffrow.html#ga1afd49bf564f21b0b980ddc2cbf5434e" title="Add two rows.">FfAddRow()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">noc</td><td>Number of columns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga80a63e88c5e305f287388c9c29b70360"></a><!-- doxytag: member="meataxe.h::FfStepPtr" ref="ga80a63e88c5e305f287388c9c29b70360" args="(PTR *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FfStepPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Advance to next row. </p>
<p>This function increments a pointer by 1 row. The row size must have been set before with <a class="el" href="group__ff.html#gad55c74480f586ce5be5f466b354c5092" title="Set the row length.">FfSetNoc()</a>. FfStepPtr(&amp;x) is equivalent to x = FfGetPtr(x,1). It is typically used to step through the rows of a matrix. Here is an example with a 100 by 40 matrix: </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac" title="A pointer to a row vector.">PTR</a> r, mat;
 <span class="keywordtype">int</span> i;
 <a class="code" href="group__ff.html#gad55c74480f586ce5be5f466b354c5092" title="Set the row length.">FfSetNoc</a>(40);
 mat = <a class="code" href="group__ff.html#ga7e2c19aab34a4094460616af8407823c" title="Allocate memory and initialize This function allocates a block of memory for a vector (if nrows is 1)...">FfAlloc</a>(100);
 <span class="keywordflow">for</span> (i = 1, r = mat; i &lt; 100; ++i, <a class="code" href="group__ff.html#ga80a63e88c5e305f287388c9c29b70360" title="Advance to next row.">FfStepPtr</a>(&amp;r))
     ...
</pre></div> <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__ff.html#gaafbdb3f0a67651eeae1b9cacd3200be6" title="Get row pointer.">FfGetPtr()</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Pointer to the row pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Always 0. </dd></dl>

</div>
</div>
<a class="anchor" id="gaeaabe2ff3bc369785750900f37103f74"></a><!-- doxytag: member="meataxe.h::FfSub" ref="gaeaabe2ff3bc369785750900f37103f74" args="(FEL a, FEL b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FfSub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finite field subtraction. </p>
<p>This function returns the difference of two field elements. Before calling <a class="el" href="group__ff.html#gaeaabe2ff3bc369785750900f37103f74" title="Finite field subtraction.">FfSub()</a>, the field must have been selected with <a class="el" href="group__ff.html#gaea2ee97e860179c7e9f6f5e5d9122a1b" title="Set the field order.">FfSetField()</a>. The arguments are not checked. If either argument is not in the allowed range the result is undefined and the program may crash. <a class="el" href="group__ff.html#gaeaabe2ff3bc369785750900f37103f74" title="Finite field subtraction.">FfSub()</a> may be implemented as a macro. In this case, it is guaranteed that both arguments are evaluated exactly once. </p>

</div>
</div>
<a class="anchor" id="gaa859d951af7288abe8e4c1f9b980406a"></a><!-- doxytag: member="meataxe.h::FfSwapRows" ref="gaa859d951af7288abe8e4c1f9b980406a" args="(PTR dest, PTR src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FfSwapRows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Exchange two rows This function exchanges the contents of two rows. </p>
<p>As with all row operations, the row length must have been set before with |FfSetNoc()|. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Pointer to the first row </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to the second row </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabc0c850a5c74041f839332bab7f14e0a"></a><!-- doxytag: member="meataxe.h::FfToGap" ref="gabc0c850a5c74041f839332bab7f14e0a" args="(FEL f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* FfToGap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert to GAP format. </p>
<p>This function takes a field element and returns the GAP representation of this element. The return value is a pointer to a static buffer which is overwritten on each call. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Field element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the GAP representtion of <em>f</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga47ad8e40d2cefc9da94992e6fe623f50"></a><!-- doxytag: member="meataxe.h::FfToInt" ref="ga47ad8e40d2cefc9da94992e6fe623f50" args="(FEL f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FfToInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert field element to integer. </p>
<p>This function converts a field element to an integer, using a "canonical" representation of field elements as integers which may be different from the internal representation. In particular, the prime field is mapped on {0,...p-1} with 0 representing the zero element and 1 the unit element. <a class="el" href="group__ffrow.html#ga47ad8e40d2cefc9da94992e6fe623f50" title="Convert field element to integer.">FfToInt()</a> should be used whenever field elements are to be written with printf(). </p>

</div>
</div>
<a class="anchor" id="ga1a0113d077e98ea763ff39cdf326b3ad"></a><!-- doxytag: member="kernel&#45;0.c::FfTrueRowSize" ref="ga1a0113d077e98ea763ff39cdf326b3ad" args="(int noc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t FfTrueRowSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>noc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Number of used bytes in a row. </p>
<p>This function returns the number of bytes that are actually used by a row of <em>noc</em> Elements, i.e., without counting the padding bytes. This number is less than or equal to <code>FfRowSize(noc)</code>. </p>

</div>
</div>
<a class="anchor" id="ga2a2041dc484908929f4803e2e8b2939c"></a><!-- doxytag: member="meataxe.h::FfWriteHeader" ref="ga2a2041dc484908929f4803e2e8b2939c" args="(const char *name, int fld, int nor, int noc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FILE* FfWriteHeader </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>noc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open File and Write Header. </p>
<p>This function opens a data file for input and writes the the file header. If the file does not exist, a new file is created. If the file exists it is overwritten. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>File name. </td></tr>
    <tr><td class="paramname">field</td><td>First header entry (usually the field order). </td></tr>
    <tr><td class="paramname">nor</td><td>Second header entry (usually the number of rows). </td></tr>
    <tr><td class="paramname">noc</td><td>Third header entry (usually the number of columns). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to open file, or |NULL| on error. </dd></dl>

</div>
</div>
<a class="anchor" id="gac0425c9851a076ec59771ff409cf90fd"></a><!-- doxytag: member="meataxe.h::FfWriteRows" ref="gac0425c9851a076ec59771ff409cf90fd" args="(FILE *f, PTR buf, int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FfWriteRows </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write rows This function writes 1 or more rows to a file. </p>
<p>The row size must have been set before. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Pointer to File. </td></tr>
    <tr><td class="paramname">buf</td><td>Pointer to data buffer. </td></tr>
    <tr><td class="paramname">n</td><td>Number of rows to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of rows that were successully written. A return value different from |n| indicates an error. </dd></dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="gad698cd18b748f79406cf20ea6dc64912"></a><!-- doxytag: member="meataxe.h::FfChar" ref="gad698cd18b748f79406cf20ea6dc64912" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__ff.html#gad698cd18b748f79406cf20ea6dc64912">FfChar</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Current characteristic. </p>
<p>Current characteristic.</p>
<p>Characteristic of the current field. Like FfOrder, this variable may be used anywhere, but it must not be modified directly. </p>

</div>
</div>
<a class="anchor" id="ga271e08c9c124d5463151e7ea457f72f8"></a><!-- doxytag: member="kernel&#45;0.c::FfCurrentRowSize" ref="ga271e08c9c124d5463151e7ea457f72f8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="group__ff.html#ga271e08c9c124d5463151e7ea457f72f8">FfCurrentRowSize</a> = (size_t) -1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Row size. </p>
<p>This variable contains the size of a single row in memory. Its value is always equal to <code>FfRowSize(FfNoc)</code>. The row size os always a multiple of sizeof(long). </p>

</div>
</div>
<a class="anchor" id="ga271e08c9c124d5463151e7ea457f72f8"></a><!-- doxytag: member="meataxe.h::FfCurrentRowSize" ref="ga271e08c9c124d5463151e7ea457f72f8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="group__ff.html#ga271e08c9c124d5463151e7ea457f72f8">FfCurrentRowSize</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Row size. </p>
<p>This variable contains the size of a single row in memory. Its value is always equal to <code>FfRowSize(FfNoc)</code>. The row size os always a multiple of sizeof(long). </p>

</div>
</div>
<a class="anchor" id="ga09f7794098a89b94fe64ab364c90601f"></a><!-- doxytag: member="kernel&#45;0.c::FfCurrentRowSizeIo" ref="ga09f7794098a89b94fe64ab364c90601f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__ff.html#ga09f7794098a89b94fe64ab364c90601f">FfCurrentRowSizeIo</a> = -1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>I/O row size. </p>
<p>This variable contains the number of bytes occupied by a row when stored in a data file. Its value is always equal to <code>FfTrueRowSize(FfNoc)</code>. Since there is no padding in data files, FfCurrentRowSizeIo is usually smaller than FfCurrentRowSize. </p>

</div>
</div>
<a class="anchor" id="gafbc60cf678ca46b8a235048d0fd204ea"></a><!-- doxytag: member="meataxe.h::FfGen" ref="gafbc60cf678ca46b8a235048d0fd204ea" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a> <a class="el" href="group__ff.html#gafbc60cf678ca46b8a235048d0fd204ea">FfGen</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generator. </p>
<p>Generator.</p>
<p>This variable contains a genrator for the multiplicative group of the current field. </p>

</div>
</div>
<a class="anchor" id="gafbc60cf678ca46b8a235048d0fd204ea"></a><!-- doxytag: member="zzz2.c::FfGen" ref="gafbc60cf678ca46b8a235048d0fd204ea" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a> <a class="el" href="group__ff.html#gafbc60cf678ca46b8a235048d0fd204ea">FfGen</a> = 0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Field generator. </p>
<p>Generator.</p>
<p>This variable contains a genrator for the multiplicative group of the current field. </p>

</div>
</div>
<a class="anchor" id="gaf8ebb85f6f53229ae4a43df827ddd0e8"></a><!-- doxytag: member="zzz2.c::FfNoc" ref="gaf8ebb85f6f53229ae4a43df827ddd0e8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__ff.html#gaf8ebb85f6f53229ae4a43df827ddd0e8">FfNoc</a> = 0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Current row size. </p>
<p>Number of columns for row ops.</p>
<p>Used by all low-level row operations. FfNoc is updated automatically when the row size is changed with <a class="el" href="group__ff.html#gad55c74480f586ce5be5f466b354c5092" title="Set the row length.">FfSetNoc()</a>. </p>

</div>
</div>
<a class="anchor" id="gaf8ebb85f6f53229ae4a43df827ddd0e8"></a><!-- doxytag: member="meataxe.h::FfNoc" ref="gaf8ebb85f6f53229ae4a43df827ddd0e8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__ff.html#gaf8ebb85f6f53229ae4a43df827ddd0e8">FfNoc</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Number of columns for row ops. </p>
<p>Number of columns for row ops.</p>
<p>Used by all low-level row operations. FfNoc is updated automatically when the row size is changed with <a class="el" href="group__ff.html#gad55c74480f586ce5be5f466b354c5092" title="Set the row length.">FfSetNoc()</a>. </p>

</div>
</div>
<a class="anchor" id="ga29c9610e1e3f82431f9fde08d50b33d2"></a><!-- doxytag: member="zzz2.c::FfOrder" ref="ga29c9610e1e3f82431f9fde08d50b33d2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__ff.html#ga29c9610e1e3f82431f9fde08d50b33d2">FfOrder</a> = -1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Field order. </p>
<p>Current field order.</p>
<p>FfOrder may be used in expressiond but must never modified directly. To change the current field, use <a class="el" href="group__ff.html#gaea2ee97e860179c7e9f6f5e5d9122a1b" title="Set the field order.">FfSetField()</a>. </p>

</div>
</div>
<a class="anchor" id="ga29c9610e1e3f82431f9fde08d50b33d2"></a><!-- doxytag: member="meataxe.h::FfOrder" ref="ga29c9610e1e3f82431f9fde08d50b33d2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__ff.html#ga29c9610e1e3f82431f9fde08d50b33d2">FfOrder</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Current field order. </p>
<p>Current field order.</p>
<p>FfOrder may be used in expressiond but must never modified directly. To change the current field, use <a class="el" href="group__ff.html#gaea2ee97e860179c7e9f6f5e5d9122a1b" title="Set the field order.">FfSetField()</a>. </p>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
<hr size="1"><address style="text-align: right;"><small>
MeatAxe 2.4 documentation, generated on Mon Nov 28 2011 22:17:18</small></address>
</body>
</html>
