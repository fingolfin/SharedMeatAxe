<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MeatAxe: Other Kernel Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MeatAxe&#160;<span id="projectnumber">2.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group__ff2.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Other Kernel Functions</div>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff2.html#ga88a258f384760978af565207b9da5431">SysReadLong32</a> (FILE *f, long *buf, int n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read long integers.  <a href="#ga88a258f384760978af565207b9da5431"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff2.html#ga32d29a97fda897a3c658e2943a0a189f">SysWriteLong32</a> (FILE *f, const long *buf, int n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write long integers.  <a href="#ga32d29a97fda897a3c658e2943a0a189f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff2.html#ga84c50a136fb0e885fd8b231f46114f10">FfSumAndIntersection</a> (<a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> wrk1, int *nor1, int *nor2, <a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> wrk2, int *piv)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum and Intersection of Two Vector Spaces.  <a href="#ga84c50a136fb0e885fd8b231f46114f10"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff2.html#ga59ce80c8d0a96a65964e9e279765bda1">FfCmpRows</a> (<a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> p1, <a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> p2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two Rows.  <a href="#ga59ce80c8d0a96a65964e9e279765bda1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ff2.html#ga37f39dbd6d3335acf1e9e4d11fc991eb">FfPermRow</a> (<a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> row, const long *perm, <a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a Vector by a Permutation.  <a href="#ga37f39dbd6d3335acf1e9e4d11fc991eb"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga59ce80c8d0a96a65964e9e279765bda1"></a><!-- doxytag: member="zcmprow.c::FfCmpRows" ref="ga59ce80c8d0a96a65964e9e279765bda1" args="(PTR p1, PTR p2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FfCmpRows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compare two Rows. </p>
<p>This function compares two row vectors. As with all row operations, the row length must have been set before with <a class="el" href="group__ff.html#gad55c74480f586ce5be5f466b354c5092" title="Set the row length.">FfSetNoc()</a>. The return value is negative if the first row is "less" than the second row, and it is positive if the first row is "greater" than the second row. However, the ordering defined by <a class="el" href="group__ff.html#ga59ce80c8d0a96a65964e9e279765bda1" title="Compare two Rows.">FfCmpRows()</a> depends on the internal representation of finite field elements and can differ between dirrerent kernels or between different hardware architectures. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>Pointer to the first matrix. </td></tr>
    <tr><td class="paramname">p2</td><td>Pointer to the second matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The function returns 0 if the two rows are identical. Otherwise the return value is different from 0. </dd></dl>

</div>
</div>
<a class="anchor" id="ga37f39dbd6d3335acf1e9e4d11fc991eb"></a><!-- doxytag: member="zpermrow.c::FfPermRow" ref="ga37f39dbd6d3335acf1e9e4d11fc991eb" args="(PTR row, const long *perm, PTR result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FfPermRow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long *&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiply a Vector by a Permutation. </p>
<p>This function multiplies the vector <em>row</em> from the right with the permutation <em>perm</em> and stores the result in <em>result</em>. Multiplication of vectors by permutations is defined as follows: if the permutation maps i to k, then the i-ith mark of the vector is stored in the k-th position of the result.</p>
<p>Note: <em>result</em> and <em>row</em> must not overlap. Otherwise the result is undefined. </p>

</div>
</div>
<a class="anchor" id="ga84c50a136fb0e885fd8b231f46114f10"></a><!-- doxytag: member="sumint.c::FfSumAndIntersection" ref="ga84c50a136fb0e885fd8b231f46114f10" args="(PTR wrk1, int *nor1, int *nor2, PTR wrk2, int *piv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FfSumAndIntersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>wrk1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nor2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>wrk2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>piv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sum and Intersection of Two Vector Spaces. </p>
<p>Given two vector spaces V,W∊F<sup>n</sup>, this function calculates the sum and the intersection of the spaces, using the Zassenhaus algorithm. Each of the two spaces is given by a set of generating vectors, which need not be linearly independent. Before calling SumAndIntersection() the caller must allocate and initialize two workspaces and a pivot table:</p>
<ul>
<li>Both workspaces must have n₁+n₂ rows, where n₁ and n₂ are the number of generating vectos for the two subspaces.</li>
<li>Workspace 1 must contain the concatenation of the generating sets for the two subspaces. Work space 2 need not be initialized.</li>
<li>The pivot table, must be large enough for at least n₁+n₂ entries. It need not be initialized.</li>
</ul>
<p>The variables pointed to by <em>nor1</em> and <em>nor2</em> must contain the numbers n₁ and n₂, respectively. On return, *<em>nor1</em> contains the dimension of V+W, and *<em>nor2</em> contains the dimension of V∩W. The first dim(V+W) rows of <em>wrk1</em> contain a basis of V+W, and a basis of V∩W can be found in <em>wrk2</em> starting at position dim(V+W). Both bases are in echelon form, and <em>piv</em> contains the pivot table for the bases. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">wrk1</td><td>Workspace 1. </td></tr>
    <tr><td class="paramname">nor1</td><td>Input: number of generators for V, output: dim(V+W). </td></tr>
    <tr><td class="paramname">nor2</td><td>Input: number of generators for W, output: dim(V∩W). </td></tr>
    <tr><td class="paramname">wrk2</td><td>Workspace 2. </td></tr>
    <tr><td class="paramname">piv</td><td>Pivot table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga88a258f384760978af565207b9da5431"></a><!-- doxytag: member="intio.c::SysReadLong32" ref="ga88a258f384760978af565207b9da5431" args="(FILE *f, long *buf, int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SysReadLong32 </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read long integers. </p>
<p>This function reads @ n long integers from the file <em>f</em> into the array <em>buf</em>. <em>buf</em> must point to a memory area of at least n*sizeof(long) bytes and the file must be open for reading. The return value indicates how many integers have actually been read. This number may be less than <em>n</em> because the end of file was encountered while reading. A negative return value indicates a file i/o error.</p>
<p>SysReadLong32() expects that the numbers in the file are 4-byte integers in little-endian format, i.e. the least significant byte first. Using a machine-independent data format makes MeatAxe data files more portable, but there are also some disadvantages:</p>
<ul>
<li>The conversion to and from machine-independent format involves several arithmetic operations for each number read/written.</li>
<li>The highest number which can be read/written is 2<sup>32</sup>-1. <dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>File to read from. </td></tr>
    <tr><td class="paramname">buf</td><td>Pointer to buffer. </td></tr>
    <tr><td class="paramname">n</td><td>Number of integers to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of integers that were actually read, or $/1$ on error. </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ga32d29a97fda897a3c658e2943a0a189f"></a><!-- doxytag: member="intio.c::SysWriteLong32" ref="ga32d29a97fda897a3c658e2943a0a189f" args="(FILE *f, const long *buf, int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SysWriteLong32 </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write long integers. </p>
<p>This function writes <em>n</em> long integers from the the array <em>buf</em> to the file <em>f</em>. <em>buf</em> must point to a memory area of at least n*sizeof(long) bytes and <em>f</em> must be open for writing. The numbers are written in a machine-independent format which can be read by SysReadLong(). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>File to write to. </td></tr>
    <tr><td class="paramname">buf</td><td>Pointer to buffer. </td></tr>
    <tr><td class="paramname">n</td><td>Number of integers to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of integers that were written, or $-1$ on error. </dd></dl>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
<hr size="1"><address style="text-align: right;"><small>
MeatAxe 2.4 documentation, generated on Mon Nov 28 2011 22:17:18</small></address>
</body>
</html>
