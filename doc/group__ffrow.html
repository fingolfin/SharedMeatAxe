<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MeatAxe: Row Operations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MeatAxe&#160;<span id="projectnumber">2.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group__ffrow.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Row Operations</div>  </div>
</div>
<div class="contents">
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>All row operations at kernel level use a global row size which can be set with <a class="el" href="group__ff.html#gad55c74480f586ce5be5f466b354c5092" title="Set the row length.">FfSetNoc()</a>. </p>
<p>The current row size is available in the global variable FfNoc.</p>
<p>A (row) vector is stored in memory as an array of bytes. The actual size of a row depends on the number of marks in the row and on the field order, because several field elements may be packed into one byte. However, the size is always a multiple of sizeof(long). Thus, there may be unused bytes at the end of a row. The contents of these extra bytes (and even the contents of unused bits in partially used bytes) is not defined. For this reason, memory must be initialized before it is used, or else some functions as <a class="el" href="group__ff.html#ga59ce80c8d0a96a65964e9e279765bda1" title="Compare two Rows.">FfCmpRows()</a> may fail.</p>
<p>Packing of field elements is used for field orders less than 17. Let q be the field order and m the largest natural number with q<sup>m</sup>â‰¤256. Then, m elements k<sub>0</sub>,...k<sub>n-1</sub> are packed into one byte as k<sub>0</sub>+k<sub>1</sub>q+k<sub>2</sub>q<sup>2</sup>+... Packing of field elements is used exclusively for rows (vectors), not for polynomials or other data types.</p>
<p>Because of packing you cannot access the marks of a row with the usual bracket notation. Instead, the MeatAxe library provides functions which store and extract marks.</p>
<p>Packed rows must be initialized before they are used. <a class="el" href="group__ffrow.html#gaec649872c5347b324a0a1276b99ab375" title="Insert a mark into a row This function inserts the field element mark at position col into row...">FfInsert()</a> (and many other row operations) will produce strange results if used with uninitialized rows. Memory is initialized automatically in the following cases: allocation with <a class="el" href="group__ff.html#ga7e2c19aab34a4094460616af8407823c" title="Allocate memory and initialize This function allocates a block of memory for a vector (if nrows is 1)...">FfAlloc()</a>, copying a row with <a class="el" href="group__ff.html#gaa9ad04522cf1db9f879baa892e2075f0" title="Copy a row.">FfCopyRow()</a>, reading a row from a file. A row can be initialized manually by multiplication with zero: FfMulRow(ptr,FF_ZERO). The latter works even if no field has been selected.</p>
<p>A matrix is stored as a sequence of rows with no extra space between them. The rows and columns of a matrix are numbered 0,1,2,...n-1. Column vectors may be stored as matrices with one column but each mark of the vector will occupy 4 Bytes. </p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ffrow.html#ga1afd49bf564f21b0b980ddc2cbf5434e">FfAddRow</a> (<a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> dest, <a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> src)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two rows.  <a href="#ga1afd49bf564f21b0b980ddc2cbf5434e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ffrow.html#ga909e3cd284a59c57f69debbea029b1ea">FfAddRowPartial</a> (<a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> dest, <a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> src, int first, int len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a part two rows.  <a href="#ga909e3cd284a59c57f69debbea029b1ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ffrow.html#ga71d62ce3689f54e934b90bad709d8b82">FfMulRow</a> (<a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> row, <a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a> mark)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a row by a coefficient.  <a href="#ga71d62ce3689f54e934b90bad709d8b82"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ffrow.html#ga2a886cd816b5adb75fd8a01e388e4082">FfAddMulRow</a> (<a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> dest, <a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> src, <a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a> f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a multiple of a row.  <a href="#ga2a886cd816b5adb75fd8a01e388e4082"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ffrow.html#ga262afe05b2024b456c7e115b3d4cee83">FfFromInt</a> (int l)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert integer to field element.  <a href="#ga262afe05b2024b456c7e115b3d4cee83"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ffrow.html#ga47ad8e40d2cefc9da94992e6fe623f50">FfToInt</a> (<a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a> f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert field element to integer.  <a href="#ga47ad8e40d2cefc9da94992e6fe623f50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ffrow.html#gad7fd5ec7f0f6003159d73a269648ffe3">FfMapRow</a> (<a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> row, <a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> matrix, int nor, <a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a vector by a matrix.  <a href="#gad7fd5ec7f0f6003159d73a269648ffe3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ffrow.html#ga4991816cc92dbc53c8945825b88a86c7">FfScalarProduct</a> (<a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> a, <a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar Product of Two Vectors.  <a href="#ga4991816cc92dbc53c8945825b88a86c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ffrow.html#gaea551734d2fbc8c28659f58a18a0eafb">FfExtractColumn</a> (<a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> mat, int nor, int col, <a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">!section kernel.ff.row Extract one column of a matrix.  <a href="#gaea551734d2fbc8c28659f58a18a0eafb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ffrow.html#gaec649872c5347b324a0a1276b99ab375">FfInsert</a> (<a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> row, int col, <a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a> mark)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a mark into a row This function inserts the field element <em>mark</em> at position <em>col</em> into <em>row</em>.  <a href="#gaec649872c5347b324a0a1276b99ab375"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ffrow.html#ga737504e6bf1010575cf78f5c2f8aa0fe">FfExtract</a> (<a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> row, int col)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">!function FfExtract "Extract a mark from a row"  <a href="#ga737504e6bf1010575cf78f5c2f8aa0fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ffrow.html#ga71b8e6f4640a6df2f8a41d250ad743ae">FfFindPivot</a> (<a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> row, <a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a> *mark)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find pivot column.  <a href="#ga71b8e6f4640a6df2f8a41d250ad743ae"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga2a886cd816b5adb75fd8a01e388e4082"></a><!-- doxytag: member="kernel&#45;0.c::FfAddMulRow" ref="ga2a886cd816b5adb75fd8a01e388e4082" args="(PTR dest, PTR src, FEL f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FfAddMulRow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a multiple of a row. </p>
<p>This function adds a multiple of <em>src</em> to <em>dest</em>. </p>

</div>
</div>
<a class="anchor" id="ga1afd49bf564f21b0b980ddc2cbf5434e"></a><!-- doxytag: member="kernel&#45;0.c::FfAddRow" ref="ga1afd49bf564f21b0b980ddc2cbf5434e" args="(PTR dest, PTR src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> FfAddRow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add two rows. </p>
<p>This function adds src to dest. Field order and row size must have been set before. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The row to add to. </td></tr>
    <tr><td class="paramname">src</td><td>The row to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Always returns dest. </dd></dl>

</div>
</div>
<a class="anchor" id="ga909e3cd284a59c57f69debbea029b1ea"></a><!-- doxytag: member="kernel&#45;0.c::FfAddRowPartial" ref="ga909e3cd284a59c57f69debbea029b1ea" args="(PTR dest, PTR src, int first, int len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> FfAddRowPartial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a part two rows. </p>
<p>This works like <a class="el" href="group__ffrow.html#ga1afd49bf564f21b0b980ddc2cbf5434e" title="Add two rows.">FfAddRow()</a>, but the operation is performed only on a given range of columns. Note that the working range is not specified as column indexes but in units of long integers! </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The row to add to. </td></tr>
    <tr><td class="paramname">src</td><td>The row to add. </td></tr>
    <tr><td class="paramname">first</td><td>Number of long integers to skip. </td></tr>
    <tr><td class="paramname">len</td><td>Number of long integers to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Always returns dest. </dd></dl>

</div>
</div>
<a class="anchor" id="ga737504e6bf1010575cf78f5c2f8aa0fe"></a><!-- doxytag: member="kernel&#45;0.c::FfExtract" ref="ga737504e6bf1010575cf78f5c2f8aa0fe" args="(PTR row, int col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a> FfExtract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>!function FfExtract "Extract a mark from a row" </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Pointer to the row. </td></tr>
    <tr><td class="paramname">col</td><td>Index of mark to extract (0-based). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>|col|-th entry of |row|. !description This function returns the entry at position |col| of a row. Note that column indexes start with 0, i.e., |FfExtract(row,0)| returns the first entry of a row. Like |FfInsert()|, this function does not depend on the current row size. Reading beyond the end of a row will probably not produce an error, but the result is undefined. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__ff.html#gaec649872c5347b324a0a1276b99ab375" title="Insert a mark into a row This function inserts the field element mark at position col into row...">FfInsert</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaea551734d2fbc8c28659f58a18a0eafb"></a><!-- doxytag: member="kernel&#45;0.c::FfExtractColumn" ref="gaea551734d2fbc8c28659f58a18a0eafb" args="(PTR mat, int nor, int col, PTR result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FfExtractColumn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>!section kernel.ff.row Extract one column of a matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Pointer to the matrix. </td></tr>
    <tr><td class="paramname">nor</td><td>Number of rows in matrix. </td></tr>
    <tr><td class="paramname">col</td><td>Column to extract (starting with 1). </td></tr>
    <tr><td class="paramname">result</td><td>Pointer to buffer for the extracted column. !description This function extracts one column out of a matrix and stores it as a row vector in |result|. The number of columns of the matrix must have been set with |FfSetNoc()|. |nor| is the number of rows in the matrix. The result is a row with |nor| entries, i.e., the length of |result| must be at least |nor|. |mat| and |result| must not overlap, or the result is undefined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga71b8e6f4640a6df2f8a41d250ad743ae"></a><!-- doxytag: member="kernel&#45;0.c::FfFindPivot" ref="ga71b8e6f4640a6df2f8a41d250ad743ae" args="(PTR row, FEL *mark)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FfFindPivot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a> *&#160;</td>
          <td class="paramname"><em>mark</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find pivot column. </p>
<p>This function scans the vector <em>row</em> and finds the first non-zero mark. The mark is stored into <code>*mark</code> and its position (counting from 0) is returned. If the whole vector is zero, FfFindPivot() returns -1 and leaves <code>*mark</code> unchanged. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Pointer to the row. </td></tr>
    <tr><td class="paramname">mark</td><td>Buffer for pivot element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Index of the first non-zero entry in <em>row</em> or -1 if all entries are zero. </dd></dl>

</div>
</div>
<a class="anchor" id="ga262afe05b2024b456c7e115b3d4cee83"></a><!-- doxytag: member="kernel&#45;0.c::FfFromInt" ref="ga262afe05b2024b456c7e115b3d4cee83" args="(int l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a> FfFromInt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert integer to field element. </p>
<p>This function converts an integer to a field element using the same mapping as explained under <a class="el" href="group__ffrow.html#ga47ad8e40d2cefc9da94992e6fe623f50" title="Convert field element to integer.">FfToInt()</a>. Both functions are inverse in the sense that the expression <code>f == FfFromInt(FfToInt(f))</code> is always true for valid field elements. <a class="el" href="group__ffrow.html#ga262afe05b2024b456c7e115b3d4cee83" title="Convert integer to field element.">FfFromInt()</a> should be used whenever field elements are to be read with scanf(). </p>

</div>
</div>
<a class="anchor" id="gaec649872c5347b324a0a1276b99ab375"></a><!-- doxytag: member="kernel&#45;0.c::FfInsert" ref="gaec649872c5347b324a0a1276b99ab375" args="(PTR row, int col, FEL mark)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FfInsert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a>&#160;</td>
          <td class="paramname"><em>mark</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert a mark into a row This function inserts the field element <em>mark</em> at position <em>col</em> into <em>row</em>. </p>
<p>Column indexes start with 0. Before this function can be used, the field must be selected with <a class="el" href="group__ff.html#gaea2ee97e860179c7e9f6f5e5d9122a1b" title="Set the field order.">FfSetField()</a>. FfInsert() does not need the row size beeing set correctly. For example, if you are working with rows of different size, you do not have to call <a class="el" href="group__ff.html#gad55c74480f586ce5be5f466b354c5092" title="Set the row length.">FfSetNoc()</a> prior to each FfInsert(). On the other hand, there is no protection against writing beyond the end of a row.</p>
<p>If the MeatAxe is compiled with the DEBUG option FfInsert() checks that <em>mark</em> is a valid field element and <em>col</em> is not negative. If also the PARANOID option was in effect during compilation, FfInsert() also checks if <em>col</em> is less than or equal to the current row size. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Pointer to the row. </td></tr>
    <tr><td class="paramname">col</td><td>Insert position (0-based). </td></tr>
    <tr><td class="paramname">mark</td><td>Value to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad7fd5ec7f0f6003159d73a269648ffe3"></a><!-- doxytag: member="kernel&#45;0.c::FfMapRow" ref="gad7fd5ec7f0f6003159d73a269648ffe3" args="(PTR row, PTR matrix, int nor, PTR result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FfMapRow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiply a vector by a matrix. </p>
<p>This function multiplies the vector <em>row</em> from the right by the matrix <em>mat</em> and stores the result into <em>result</em>. The number of columns in both <em>mat</em> and <em>result</em> is determined by the current row size. (see <a class="el" href="group__ff.html#gaf8ebb85f6f53229ae4a43df827ddd0e8" title="Number of columns for row ops.">FfNoc()</a>). </p>
<dl class="attention"><dt><b>Attention:</b></dt><dd><em>result</em> and <em>row</em> must not overlap. Otherwise the result is undefined. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">row</td><td>The source vector (FfNoc columns). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">matrix</td><td>The matrix (nor by FfNoc). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nor</td><td>number of rows in the matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>The resulting vector (<em>nor</em> columns). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga71d62ce3689f54e934b90bad709d8b82"></a><!-- doxytag: member="kernel&#45;0.c::FfMulRow" ref="ga71d62ce3689f54e934b90bad709d8b82" args="(PTR row, FEL mark)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FfMulRow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a>&#160;</td>
          <td class="paramname"><em>mark</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiply a row by a coefficient. </p>
<p>This function multiplies each element of <em>row</em> by <em>mark</em>. The row size and field order must have been set before. Multiplying a row with zero (FF_ZERO) initializes all elements to zero and is permitted even if <em>row</em> points into uninitialized memory. </p>

</div>
</div>
<a class="anchor" id="ga4991816cc92dbc53c8945825b88a86c7"></a><!-- doxytag: member="kernel&#45;0.c::FfScalarProduct" ref="ga4991816cc92dbc53c8945825b88a86c7" args="(PTR a, PTR b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a> FfScalarProduct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scalar Product of Two Vectors. </p>
<p>Given two vectors <img class="formulaInl" alt="$a=(a_i)$" src="form_0.png"/> and <img class="formulaInl" alt="$b=(b_i)$" src="form_1.png"/>, this function calculates the scalar product <img class="formulaInl" alt="$p=\sum_ia_ib_i$" src="form_2.png"/>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first vector. </td></tr>
    <tr><td class="paramname">b</td><td>The second vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Scalar product of the two vectors. </dd></dl>

</div>
</div>
<a class="anchor" id="ga47ad8e40d2cefc9da94992e6fe623f50"></a><!-- doxytag: member="kernel&#45;0.c::FfToInt" ref="ga47ad8e40d2cefc9da94992e6fe623f50" args="(FEL f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FfToInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert field element to integer. </p>
<p>This function converts a field element to an integer, using a "canonical" representation of field elements as integers which may be different from the internal representation. In particular, the prime field is mapped on {0,...p-1} with 0 representing the zero element and 1 the unit element. <a class="el" href="group__ffrow.html#ga47ad8e40d2cefc9da94992e6fe623f50" title="Convert field element to integer.">FfToInt()</a> should be used whenever field elements are to be written with printf(). </p>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
<hr size="1"><address style="text-align: right;"><small>
MeatAxe 2.4 documentation, generated on Mon Nov 28 2011 22:17:18</small></address>
</body>
</html>
