<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MeatAxe: Matrices over Finite Fields</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MeatAxe&#160;<span id="projectnumber">2.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group__mat.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Matrices over Finite Fields</div>  </div>
</div>
<div class="contents">
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>In the MeatAxe, a matrix over a finite field is represented by a <a class="el" href="structMatrix__t.html" title="A matrix over a finite field.">Matrix_t</a> structure. Matrices can be created in many ways, for example</p>
<ul>
<li>by calling <a class="el" href="group__mat.html#ga06620e0d44ea5adce49d162abaf8840d" title="Create a new matrix.">MatAlloc()</a>,</li>
<li>by making a copy of an existing matrix with <a class="el" href="group__mat.html#ga494bd054f6b7f259cc07c7ea7abc4a16" title="Duplicate a matrix This function creates a copy of an existing matrix.">MatDup()</a>, or</li>
<li>by reading a matrix from a data file with <a class="el" href="group__mat.html#ga09bbc8fd9eef53f4691578717bea1ef3" title="Read a matrix from a file.">MatRead()</a> or <a class="el" href="group__mat.html#ga10c390bd4d069b00a12fbe05ad2a14d3" title="Read a matrix from a file.">MatLoad()</a>.</li>
</ul>
<p>The application is responsible for releasing matrices which are no longer needed. Matrices can consume large amounts of memory, so it always a good idea to delete a matrix as early as possible. There is only one possibility of deleting a matrix: calling <a class="el" href="group__mat.html#gaa1eba5c99382a059b5a62b4de4292f82" title="Delete a matrix.">MatFree()</a>.</p>
<h2><a class="anchor" id="ech"></a>
Echelon form and pivot tables</h2>
<p>A matrix A with entries (a<sub>ij</sub>) is said to be in <b>echelon form</b> if the following conditions are satisfied:</p>
<ul>
<li>Each row has a first non-zero element, called the <b>pivot element</b>. The pivot element may have any value except zero.</li>
<li>If a<sub>ij</sub> is the pivot element of the i-th row, all elements below are zero, i.e., a<sub>ik</sub>=0 for all k&gt;i.</li>
</ul>
<p>If a matrix is in echelon form, the column indexes of its pivot elements are called the <b>pivot columns</b> of the matrix. The list of all pivot columns is called the <b>pivot table</b> of the matrix.</p>
<p>The <a class="el" href="structMatrix__t.html" title="A matrix over a finite field.">Matrix_t</a> structure, which represents a matrix, has a <code>PivotTable</code> field which is used to store the pivot table. When different from 0, <code>PivotTable</code> is a pointer to an array of integers containing first the pivot columns and then the non-pivot columns. This means, the size of the array is always <code>Noc:</code> the first <code>Nor</code> elements contain the pivot columns and the remaining <code>Noc-<code>Nor</code> elements</code> contain the non-pivot columns in arbitrary order. Note that for a matrix in echelon form <code>Nor</code> is always less or equal to <code>Noc</code>. </p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMatrix__t.html">Matrix_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix over a finite field.  <a href="structMatrix__t.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat.html#gaa6c1f3b0d54a8dccb48f83338a36a6cf">MatAdd</a> (<a class="el" href="structMatrix__t.html">Matrix_t</a> *dest, const <a class="el" href="structMatrix__t.html">Matrix_t</a> *src)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum of two matrices.  <a href="#gaa6c1f3b0d54a8dccb48f83338a36a6cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat.html#gaf540f605031ba857d02f2cf558b47ed1">MatClean</a> (<a class="el" href="structMatrix__t.html">Matrix_t</a> *mat, const <a class="el" href="structMatrix__t.html">Matrix_t</a> *sub)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean a matrix.  <a href="#gaf540f605031ba857d02f2cf558b47ed1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat.html#gada7faff926b57e0d21191018f4f1823b">MatCompare</a> (const <a class="el" href="structMatrix__t.html">Matrix_t</a> *a, const <a class="el" href="structMatrix__t.html">Matrix_t</a> *b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two matrices If the matrices are equal, the return value is 0.  <a href="#gada7faff926b57e0d21191018f4f1823b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat.html#ga6073b8acc3ca8db42d3b1308e29d3396">MatCopyRegion</a> (<a class="el" href="structMatrix__t.html">Matrix_t</a> *dest, int destrow, int destcol, const <a class="el" href="structMatrix__t.html">Matrix_t</a> *src, int row1, int col1, int nrows, int ncols)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a rectangular region of a matrix This function copies a rectangular region of <em>src</em> tp <em>dest</em>.  <a href="#ga6073b8acc3ca8db42d3b1308e29d3396"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat.html#ga20ad8c70e8fafd71bd49fbd4eed07a0b">MatIsValid</a> (const <a class="el" href="structMatrix__t.html">Matrix_t</a> *mat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the matrix is valid.  <a href="#ga20ad8c70e8fafd71bd49fbd4eed07a0b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat.html#ga06620e0d44ea5adce49d162abaf8840d">MatAlloc</a> (int field, int nor, int noc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new matrix.  <a href="#ga06620e0d44ea5adce49d162abaf8840d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat.html#ga4b3e8ae3d4581cfd06909ffb2db41360">MatGetPtr</a> (const <a class="el" href="structMatrix__t.html">Matrix_t</a> *mat, int row)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a row of a matrix.  <a href="#ga4b3e8ae3d4581cfd06909ffb2db41360"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat.html#ga1d7a805c571f70c31e34f9162f602272">Mat_DeletePivotTable</a> (<a class="el" href="structMatrix__t.html">Matrix_t</a> *mat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the pivot table of a matrix.  <a href="#ga1d7a805c571f70c31e34f9162f602272"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat.html#gaa1eba5c99382a059b5a62b4de4292f82">MatFree</a> (<a class="el" href="structMatrix__t.html">Matrix_t</a> *mat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a matrix.  <a href="#gaa1eba5c99382a059b5a62b4de4292f82"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat.html#gad231216fa18c8fa920f7e7c95ef73b1d">MatCut</a> (const <a class="el" href="structMatrix__t.html">Matrix_t</a> *src, int row1, int col1, int nrows, int ncols)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cut a rectangle out of a matrix.  <a href="#gad231216fa18c8fa920f7e7c95ef73b1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat.html#ga0598dca1408875ebdb88c94df5efce99">MatCutRows</a> (const <a class="el" href="structMatrix__t.html">Matrix_t</a> *src, int row1, int nrows)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a range of rows of a matrix.  <a href="#ga0598dca1408875ebdb88c94df5efce99"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat.html#ga494bd054f6b7f259cc07c7ea7abc4a16">MatDup</a> (const <a class="el" href="structMatrix__t.html">Matrix_t</a> *src)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate a matrix This function creates a copy of an existing matrix.  <a href="#ga494bd054f6b7f259cc07c7ea7abc4a16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat.html#ga940fd894c097143d7a3dfc758a6dc32a">MatEchelonize</a> (<a class="el" href="structMatrix__t.html">Matrix_t</a> *mat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce to echelon form This function performs a Gaussian elimination on the matrix |mat|.  <a href="#ga940fd894c097143d7a3dfc758a6dc32a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat.html#gad7d69d4914f40b202e191f1160b11214">MatNullity</a> (const <a class="el" href="structMatrix__t.html">Matrix_t</a> *mat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Nullity of a matrix.  <a href="#gad7d69d4914f40b202e191f1160b11214"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat.html#ga32c728600c42829bc06bb632eea82daf">MatNullity__</a> (<a class="el" href="structMatrix__t.html">Matrix_t</a> *mat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Nullity of a matrix.  <a href="#ga32c728600c42829bc06bb632eea82daf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat.html#ga2f84345fc5b50d8447b3c3c141682f7f">MatId</a> (int fl, int nor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Identity matrix This function creates an identity matrix with <em>nor</em> nows over GF(<em>fl</em>).  <a href="#ga2f84345fc5b50d8447b3c3c141682f7f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat.html#ga20820552f636570b6b61f44fb8a6d067">MatInsert_</a> (<a class="el" href="structMatrix__t.html">Matrix_t</a> *mat, const <a class="el" href="structPoly__t.html">Poly_t</a> *pol)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a matrix into a polynomial Given a square matrix A and a polynomial p over the same field, this functions calculates p(A).  <a href="#ga20820552f636570b6b61f44fb8a6d067"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat.html#gabe85ba0512d9ad196a9cc8ef50956ee2">MatInsert</a> (const <a class="el" href="structMatrix__t.html">Matrix_t</a> *mat, const <a class="el" href="structPoly__t.html">Poly_t</a> *pol)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a matrix into a polynomial Given a square matrix A and a polynomial p over the same field, this functions calculates p(A).  <a href="#gabe85ba0512d9ad196a9cc8ef50956ee2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat.html#gad558823c4f5d656143d4164838e7a2c3">MatInverse</a> (const <a class="el" href="structMatrix__t.html">Matrix_t</a> *mat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse of a matrix This function calculates the inverse of a matrix.  <a href="#gad558823c4f5d656143d4164838e7a2c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat.html#gab9718111f7c42fe1d0af862b1073d70f">MatMul</a> (<a class="el" href="structMatrix__t.html">Matrix_t</a> *dest, const <a class="el" href="structMatrix__t.html">Matrix_t</a> *src)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply matrices This function multiplies <em>dest</em> from the right by <em>src</em>.  <a href="#gab9718111f7c42fe1d0af862b1073d70f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat.html#ga0e6c14059569ebe98b1c610af71f5b8f">MatNullSpace_</a> (<a class="el" href="structMatrix__t.html">Matrix_t</a> *mat, int flags)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Null-space of a matrix This function calculates the null-space of a matrix.  <a href="#ga0e6c14059569ebe98b1c610af71f5b8f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat.html#ga3816df52cc1b2a089cc43a27fd7460ae">MatNullSpace</a> (const <a class="el" href="structMatrix__t.html">Matrix_t</a> *mat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Null-space of a matrix This function calculates the null-space of a matrix.  <a href="#ga3816df52cc1b2a089cc43a27fd7460ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat.html#gafc9357c82c1fe73ff80eea15f71c3c60">MatNullSpace__</a> (<a class="el" href="structMatrix__t.html">Matrix_t</a> *mat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Null-space of a matrix This function calculates the null-space of a matrix and deletes the original matrix.  <a href="#gafc9357c82c1fe73ff80eea15f71c3c60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat.html#ga0199cd91084c162683915bc082432338">MatOrder</a> (const <a class="el" href="structMatrix__t.html">Matrix_t</a> *mat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Order of a matrix.  <a href="#ga0199cd91084c162683915bc082432338"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat.html#ga1f99f1d8df6029caa43024f35e5c76e2">MatPivotize</a> (<a class="el" href="structMatrix__t.html">Matrix_t</a> *mat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce to echelon form.  <a href="#ga1f99f1d8df6029caa43024f35e5c76e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat.html#ga375192f076aa6b5affbe996c7bd65485">MatPrint</a> (const char *name, const <a class="el" href="structMatrix__t.html">Matrix_t</a> *m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a Matrix on stdout.  <a href="#ga375192f076aa6b5affbe996c7bd65485"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat.html#ga8e15736c076f1502120930c5cda593a0">MatPower</a> (const <a class="el" href="structMatrix__t.html">Matrix_t</a> *mat, long n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">!section obj.mat Power of a matrix.  <a href="#ga8e15736c076f1502120930c5cda593a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat.html#ga09bbc8fd9eef53f4691578717bea1ef3">MatRead</a> (FILE *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a matrix from a file.  <a href="#ga09bbc8fd9eef53f4691578717bea1ef3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat.html#ga10c390bd4d069b00a12fbe05ad2a14d3">MatLoad</a> (const char *fn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a matrix from a file.  <a href="#ga10c390bd4d069b00a12fbe05ad2a14d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat.html#ga7a2edca3247137c7a04df74017819241">MatTransposed</a> (const <a class="el" href="structMatrix__t.html">Matrix_t</a> *src)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose a matrix.  <a href="#ga7a2edca3247137c7a04df74017819241"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat.html#gacc7e0fce362468e1a89dbfec4776d48f">MatTrace</a> (const <a class="el" href="structMatrix__t.html">Matrix_t</a> *mat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace of a Matrix.  <a href="#gacc7e0fce362468e1a89dbfec4776d48f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat.html#gac61c071f417d0685dbcb8fe444feebca">MatWrite</a> (const <a class="el" href="structMatrix__t.html">Matrix_t</a> *mat, FILE *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a matrix to a file.  <a href="#gac61c071f417d0685dbcb8fe444feebca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat.html#gab3a78cc293a56e9b73a8c6b3d5254f4c">MatSave</a> (const <a class="el" href="structMatrix__t.html">Matrix_t</a> *mat, const char *fn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a matrix to a file.  <a href="#gab3a78cc293a56e9b73a8c6b3d5254f4c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat.html#gad63b9348b04e346f283df0d6e5fb692d">MatMulScalar</a> (<a class="el" href="structMatrix__t.html">Matrix_t</a> *dest, <a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a> coeff)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a Matrix by a Constant.  <a href="#gad63b9348b04e346f283df0d6e5fb692d"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga1d7a805c571f70c31e34f9162f602272"></a><!-- doxytag: member="matcore.c::Mat_DeletePivotTable" ref="ga1d7a805c571f70c31e34f9162f602272" args="(Matrix_t *mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mat_DeletePivotTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete the pivot table of a matrix. </p>
<p>This function deletes the pivot table associated with a matrix. It is used internally, applications should never call this function directly. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Pointer to the matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa6c1f3b0d54a8dccb48f83338a36a6cf"></a><!-- doxytag: member="matadd.c::MatAdd" ref="gaa6c1f3b0d54a8dccb48f83338a36a6cf" args="(Matrix_t *dest, const Matrix_t *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMatrix__t.html">Matrix_t</a>* MatAdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sum of two matrices. </p>
<p>This function adds <em>src</em> to <em>dest</em>, overwriteing the previos value in <em>dest</em>. The matrices must be over the same field and have the same dimensions. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><em>dest</em> on success, 0 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga06620e0d44ea5adce49d162abaf8840d"></a><!-- doxytag: member="matcore.c::MatAlloc" ref="ga06620e0d44ea5adce49d162abaf8840d" args="(int field, int nor, int noc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMatrix__t.html">Matrix_t</a>* MatAlloc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>noc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new matrix. </p>
<p>This function creates a new matrix with given dimensions over a given field. </p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>To destroy a matrix, use <a class="el" href="group__mat.html#gaa1eba5c99382a059b5a62b4de4292f82" title="Delete a matrix.">MatFree()</a>, not <a class="el" href="group__os.html#ga124aa4812c2d1ab9b8d2c6a8e33e87f7" title="Free memory block.">SysFree()</a>. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">field</td><td>Field order. </td></tr>
    <tr><td class="paramname">nor</td><td>Number of rows. </td></tr>
    <tr><td class="paramname">noc</td><td>Number of columns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the new matrix or 0 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf540f605031ba857d02f2cf558b47ed1"></a><!-- doxytag: member="matclean.c::MatClean" ref="gaf540f605031ba857d02f2cf558b47ed1" args="(Matrix_t *mat, const Matrix_t *sub)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MatClean </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>sub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clean a matrix. </p>
<p>This function "cleans" a matrix with a space, i.e., it adds suitable linear combinations of the rows in <em>sub</em> to the rows of <em>mat</em> such that all pivot columns in <em>mat</em> are zero. Both matrices must be over the same field and have the same number of colums. The second matrix, <em>sub</em>, must be in echelon form. The cleaned matrix is reduced to echelon form. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Rank of the cleaned matrix, or -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="gada7faff926b57e0d21191018f4f1823b"></a><!-- doxytag: member="matcmp.c::MatCompare" ref="gada7faff926b57e0d21191018f4f1823b" args="(const Matrix_t *a, const Matrix_t *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MatCompare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compare two matrices If the matrices are equal, the return value is 0. </p>
<p>Otherwise the return value is positive, if <em>a</em> is "greater" than <em>b</em> and negative, if <em>a</em> is "less" than <em>b</em>. The ordering matrices is defined as follows:</p>
<ul>
<li>If the matrices are over different fields, the matrix over the smaller field is smaller.</li>
<li>Otherwise, if the matrices have different number of columns, the matrix with the smaller number of columns is smaller.</li>
<li>Otherwise, if the matrices have different number of rows, the matrix with the smaller number of rows is smaller.</li>
<li>Otherwise, the relation is determined by the return value of FfCmpRow() on the first row that is not equal in both matrices.</li>
</ul>
<p>In case an error occurs, the return value is -1. But note that a return value of -1 does not necessarily mean that an error has occured. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First matrix. </td></tr>
    <tr><td class="paramname">b</td><td>Second matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the matrices are equal, nonzero otherwise (see description). </dd></dl>

</div>
</div>
<a class="anchor" id="ga6073b8acc3ca8db42d3b1308e29d3396"></a><!-- doxytag: member="matcopy.c::MatCopyRegion" ref="ga6073b8acc3ca8db42d3b1308e29d3396" args="(Matrix_t *dest, int destrow, int destcol, const Matrix_t *src, int row1, int col1, int nrows, int ncols)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MatCopyRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destrow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy a rectangular region of a matrix This function copies a rectangular region of <em>src</em> tp <em>dest</em>. </p>
<p>The source region is defined by its upper left corner and dimensions, the destination region is specified by its upper left corner and has the same dimensions. Both <em>nrows</em> and <em>ncols</em> can be given as -1. In this case the region extends up to the last row or last column, respectively. The two matrices must be over the same field. Both source and destination region must not exceed the matrices' dimensions. In particular, it is not possible to extend the destination matrix by using MatCopyRegion(). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Pointer to the destination matrix. </td></tr>
    <tr><td class="paramname">destrow</td><td>Destination row. </td></tr>
    <tr><td class="paramname">destcol</td><td>Destination column. </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to the source matrix. </td></tr>
    <tr><td class="paramname">row1</td><td>First row in region. </td></tr>
    <tr><td class="paramname">col1</td><td>First column in region. </td></tr>
    <tr><td class="paramname">nrows</td><td>Number of rows to copy. -1 means as many rows as possible. </td></tr>
    <tr><td class="paramname">ncols</td><td>Number of columns to copy. -1 means as many columns as possible. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="gad231216fa18c8fa920f7e7c95ef73b1d"></a><!-- doxytag: member="matcut.c::MatCut" ref="gad231216fa18c8fa920f7e7c95ef73b1d" args="(const Matrix_t *src, int row1, int col1, int nrows, int ncols)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMatrix__t.html">Matrix_t</a>* MatCut </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cut a rectangle out of a matrix. </p>
<p>This function creates a new matrix containing a copy of a rectangular region of the source matrix. The region, defined by <em>row1</em>, <em>col1</em>, <em>nrows</em> and <em>ncols</em>, must not exceed the matrix. However, both <em>nrows</em> and <em>ncols</em> may be -1. In this case the region extends up to the last row or last column, respectivly. For example, to extract the first 10 rows from a matrix independently of the number of columns, you could say </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="group__mat.html#gad231216fa18c8fa920f7e7c95ef73b1d" title="Cut a rectangle out of a matrix.">MatCut</a>(mat,0,0,10,-1)
</pre></div> <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__mat.html#ga6073b8acc3ca8db42d3b1308e29d3396" title="Copy a rectangular region of a matrix This function copies a rectangular region of src tp dest...">MatCopyRegion</a> <a class="el" href="group__mat.html#ga0598dca1408875ebdb88c94df5efce99" title="Copy a range of rows of a matrix.">MatCutRows</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Pointer to the matrix. </td></tr>
    <tr><td class="paramname">row1</td><td>First row in region. </td></tr>
    <tr><td class="paramname">col1</td><td>First column in region. </td></tr>
    <tr><td class="paramname">nrows</td><td>Number of rows to cut. -1 means as many rows as possible. </td></tr>
    <tr><td class="paramname">ncols</td><td>Number of columns to cut. -1 means as many columns as possible. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to a new matrix containing the specified region, or 0 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0598dca1408875ebdb88c94df5efce99"></a><!-- doxytag: member="matcut.c::MatCutRows" ref="ga0598dca1408875ebdb88c94df5efce99" args="(const Matrix_t *src, int row1, int nrows)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMatrix__t.html">Matrix_t</a>* MatCutRows </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy a range of rows of a matrix. </p>
<p>This function creates a new matrix containing a range of consecutive rows of the source matrix. The range must now exceed the matrix's dimensions. However, <em>nrows</em> may be given as -1, meaning "up to the last row". </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__mat.html#ga6073b8acc3ca8db42d3b1308e29d3396" title="Copy a rectangular region of a matrix This function copies a rectangular region of src tp dest...">MatCopyRegion</a> <a class="el" href="group__mat.html#ga0598dca1408875ebdb88c94df5efce99" title="Copy a range of rows of a matrix.">MatCutRows</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Pointer to the matrix. </td></tr>
    <tr><td class="paramname">row1</td><td>First row in region. </td></tr>
    <tr><td class="paramname">nrows</td><td>Number of rows to cut. -1 means as many rows as possible. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new matrix containing the specified rows of <em>src</em>, or 0 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga494bd054f6b7f259cc07c7ea7abc4a16"></a><!-- doxytag: member="matdup.c::MatDup" ref="ga494bd054f6b7f259cc07c7ea7abc4a16" args="(const Matrix_t *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMatrix__t.html">Matrix_t</a>* MatDup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Duplicate a matrix This function creates a copy of an existing matrix. </p>
<p>The caller is responsible for destroying the copy with <a class="el" href="group__mat.html#gaa1eba5c99382a059b5a62b4de4292f82" title="Delete a matrix.">MatFree()</a> when it is no longer needed. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A copy of the source Matrix, or 0 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga940fd894c097143d7a3dfc758a6dc32a"></a><!-- doxytag: member="matech.c::MatEchelonize" ref="ga940fd894c097143d7a3dfc758a6dc32a" args="(Matrix_t *mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MatEchelonize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reduce to echelon form This function performs a Gaussian elimination on the matrix |mat|. </p>
<p>On return, |mat| is in semi echelon form and a pivot table has been attatched to the matrix. If the rank of |mat| was smaller than the number of rows, some rows are removed during the process. This function can also be used to rebuild the pivot table after the matrix has been modified. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Pointer to the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Rank of <em>mat</em>, or -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa1eba5c99382a059b5a62b4de4292f82"></a><!-- doxytag: member="matcore.c::MatFree" ref="gaa1eba5c99382a059b5a62b4de4292f82" args="(Matrix_t *mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MatFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete a matrix. </p>
<p>This function frees a matrix which has beed created by <a class="el" href="group__mat.html#ga06620e0d44ea5adce49d162abaf8840d" title="Create a new matrix.">MatAlloc()</a>. Freeing includes the internal data buffers as well as the <a class="el" href="structMatrix__t.html" title="A matrix over a finite field.">Matrix_t</a> structure itself. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Pointer to the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4b3e8ae3d4581cfd06909ffb2db41360"></a><!-- doxytag: member="matcore.c::MatGetPtr" ref="ga4b3e8ae3d4581cfd06909ffb2db41360" args="(const Matrix_t *mat, int row)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ff.html#ga2dc160f7cd3b7190becfc9eab62b58ac">PTR</a> MatGetPtr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pointer to a row of a matrix. </p>
<p>This function returns a pointer to the specified row of a matrix. Row numbers start from 0. The current row size is not changed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Pointer to the matrix. </td></tr>
    <tr><td class="paramname">row</td><td>Row index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the selected row or 0 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2f84345fc5b50d8447b3c3c141682f7f"></a><!-- doxytag: member="matid.c::MatId" ref="ga2f84345fc5b50d8447b3c3c141682f7f" args="(int fl, int nor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMatrix__t.html">Matrix_t</a>* MatId </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Identity matrix This function creates an identity matrix with <em>nor</em> nows over GF(<em>fl</em>). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">fl</td><td>Field order. </td></tr>
    <tr><td class="paramname">nor</td><td>Number of rows. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the matrix, or 0 on error. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__mat.html#ga06620e0d44ea5adce49d162abaf8840d" title="Create a new matrix.">MatAlloc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gabe85ba0512d9ad196a9cc8ef50956ee2"></a><!-- doxytag: member="matins.c::MatInsert" ref="gabe85ba0512d9ad196a9cc8ef50956ee2" args="(const Matrix_t *mat, const Poly_t *pol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMatrix__t.html">Matrix_t</a>* MatInsert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPoly__t.html">Poly_t</a> *&#160;</td>
          <td class="paramname"><em>pol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert a matrix into a polynomial Given a square matrix A and a polynomial p over the same field, this functions calculates p(A). </p>
<p>Unlike <a class="el" href="group__mat.html#ga20820552f636570b6b61f44fb8a6d067" title="Insert a matrix into a polynomial Given a square matrix A and a polynomial p over the same field...">MatInsert_()</a> this function returns a new matrix and does not modify the original matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Pointer to the matrix. </td></tr>
    <tr><td class="paramname">pol</td><td>Pointer to the polynomial. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><em>pol</em>(<em>mat</em>), or 0 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga20820552f636570b6b61f44fb8a6d067"></a><!-- doxytag: member="matins.c::MatInsert_" ref="ga20820552f636570b6b61f44fb8a6d067" args="(Matrix_t *mat, const Poly_t *pol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMatrix__t.html">Matrix_t</a>* MatInsert_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPoly__t.html">Poly_t</a> *&#160;</td>
          <td class="paramname"><em>pol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert a matrix into a polynomial Given a square matrix A and a polynomial p over the same field, this functions calculates p(A). </p>
<p>Unlike <a class="el" href="group__mat.html#gabe85ba0512d9ad196a9cc8ef50956ee2" title="Insert a matrix into a polynomial Given a square matrix A and a polynomial p over the same field...">MatInsert()</a> this function is destructive. The result is stored in the original matrix and the old value is lost. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Pointer to the matrix. </td></tr>
    <tr><td class="paramname">pol</td><td>Pointer to the polynomial. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The function returns <em>mat</em>, or 0 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="gad558823c4f5d656143d4164838e7a2c3"></a><!-- doxytag: member="matinv.c::MatInverse" ref="gad558823c4f5d656143d4164838e7a2c3" args="(const Matrix_t *mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMatrix__t.html">Matrix_t</a>* MatInverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inverse of a matrix This function calculates the inverse of a matrix. </p>
<p><em>mat</em> must be a non-singular square matrix. The inverse matrix is returned in a newly allocated <a class="el" href="structMatrix__t.html" title="A matrix over a finite field.">Matrix_t</a> structure, and the original matrix remains unchanged. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Pointer to the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Inverse matrix or 0 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga20ad8c70e8fafd71bd49fbd4eed07a0b"></a><!-- doxytag: member="matcore.c::MatIsValid" ref="ga20ad8c70e8fafd71bd49fbd4eed07a0b" args="(const Matrix_t *mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MatIsValid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if the matrix is valid. </p>
<p>This function checks if the argument is a pointer to a valid matrix. If the matrix is o.k., the function returns 1. Otherwise, an error is signalled and, if the error handler does not terminate the program, the function returns 0. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Matrix to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the matrix is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga10c390bd4d069b00a12fbe05ad2a14d3"></a><!-- doxytag: member="matread.c::MatLoad" ref="ga10c390bd4d069b00a12fbe05ad2a14d3" args="(const char *fn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMatrix__t.html">Matrix_t</a>* MatLoad </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a matrix from a file. </p>
<p>!synopsis <a class="el" href="structMatrix__t.html" title="A matrix over a finite field.">Matrix_t</a> *MatLoad(const char *fn); </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>File name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the matrix, or |NULL| on error. !description This function opens a file, reads a single matrix, and closes the file.</dd></dl>
<p>To read more than one matrix from a file, use |MatRead()|. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__mat.html#ga09bbc8fd9eef53f4691578717bea1ef3" title="Read a matrix from a file.">MatRead</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab9718111f7c42fe1d0af862b1073d70f"></a><!-- doxytag: member="matmul.c::MatMul" ref="gab9718111f7c42fe1d0af862b1073d70f" args="(Matrix_t *dest, const Matrix_t *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMatrix__t.html">Matrix_t</a>* MatMul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiply matrices This function multiplies <em>dest</em> from the right by <em>src</em>. </p>
<p>The matrices must be compatible for multiplication, i.e. they must be over the same field, and the number of columns of <em>dest</em> must be equal to the number of rows of <em>src</em>. The result of the multiplication is stored in <em>dest</em>, overwriting the original contents. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__mat.html#ga8e15736c076f1502120930c5cda593a0" title="!section obj.mat Power of a matrix.">MatPower()</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Left factor and result. </td></tr>
    <tr><td class="paramname">src</td><td>Right factor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The function returns <em>dest</em>, or 0 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="gad63b9348b04e346f283df0d6e5fb692d"></a><!-- doxytag: member="mmulscal.c::MatMulScalar" ref="gad63b9348b04e346f283df0d6e5fb692d" args="(Matrix_t *dest, FEL coeff)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMatrix__t.html">Matrix_t</a>* MatMulScalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a>&#160;</td>
          <td class="paramname"><em>coeff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiply a Matrix by a Constant. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Pointer to the matrix. </td></tr>
    <tr><td class="paramname">coeff</td><td>Value to multiply with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The function returns <em>dest</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="gad7d69d4914f40b202e191f1160b11214"></a><!-- doxytag: member="matech.c::MatNullity" ref="gad7d69d4914f40b202e191f1160b11214" args="(const Matrix_t *mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long MatNullity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Nullity of a matrix. </p>
<p>This function calculates the dimension of the null-space of a matrix. Unlike <a class="el" href="group__mat.html#ga32c728600c42829bc06bb632eea82daf" title="Nullity of a matrix.">MatNullity__()</a> this function does not modify the matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Pointer to the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Nullity of the matrix, or -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga32c728600c42829bc06bb632eea82daf"></a><!-- doxytag: member="matech.c::MatNullity__" ref="ga32c728600c42829bc06bb632eea82daf" args="(Matrix_t *mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long MatNullity__ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Nullity of a matrix. </p>
<p>This function calculates the dimension of the null-space of a matrix and deletes the matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Pointer to the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Nullity of <em>mat</em>, or -$ on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3816df52cc1b2a089cc43a27fd7460ae"></a><!-- doxytag: member="matnull.c::MatNullSpace" ref="ga3816df52cc1b2a089cc43a27fd7460ae" args="(const Matrix_t *mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMatrix__t.html">Matrix_t</a>* MatNullSpace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Null-space of a matrix This function calculates the null-space of a matrix. </p>
<p>Unlike <a class="el" href="group__mat.html#ga0e6c14059569ebe98b1c610af71f5b8f" title="Null-space of a matrix This function calculates the null-space of a matrix.">MatNullSpace_()</a> and <a class="el" href="group__mat.html#gafc9357c82c1fe73ff80eea15f71c3c60" title="Null-space of a matrix This function calculates the null-space of a matrix and deletes the original m...">MatNullSpace__()</a>, this function does not change the original matrix, but it allocates a temporary copy of the matrix and thus needs more memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Pointer to the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the null-space, or 0 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0e6c14059569ebe98b1c610af71f5b8f"></a><!-- doxytag: member="matnull.c::MatNullSpace_" ref="ga0e6c14059569ebe98b1c610af71f5b8f" args="(Matrix_t *mat, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMatrix__t.html">Matrix_t</a>* MatNullSpace_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Null-space of a matrix This function calculates the null-space of a matrix. </p>
<p>Unlike <a class="el" href="group__mat.html#ga3816df52cc1b2a089cc43a27fd7460ae" title="Null-space of a matrix This function calculates the null-space of a matrix.">MatNullSpace()</a>, this function modifies the orginal matrix, but uses less memory since no temporary workspace is allocated. The result is in echelon form. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Pointer to the matrix. </td></tr>
    <tr><td class="paramname">flags</td><td>If nonzero, the null-space is not reduced to echelon form. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the null-space of |mat|, or |NULL| on error. </dd></dl>

</div>
</div>
<a class="anchor" id="gafc9357c82c1fe73ff80eea15f71c3c60"></a><!-- doxytag: member="matnull.c::MatNullSpace__" ref="gafc9357c82c1fe73ff80eea15f71c3c60" args="(Matrix_t *mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMatrix__t.html">Matrix_t</a>* MatNullSpace__ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Null-space of a matrix This function calculates the null-space of a matrix and deletes the original matrix. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__mat.html#ga0e6c14059569ebe98b1c610af71f5b8f" title="Null-space of a matrix This function calculates the null-space of a matrix.">MatNullSpace_()</a>, <a class="el" href="group__mat.html#ga3816df52cc1b2a089cc43a27fd7460ae" title="Null-space of a matrix This function calculates the null-space of a matrix.">MatNullSpace()</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Pointer to the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the null-space, or 0 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0199cd91084c162683915bc082432338"></a><!-- doxytag: member="matorder.c::MatOrder" ref="ga0199cd91084c162683915bc082432338" args="(const Matrix_t *mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MatOrder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Order of a matrix. </p>
<p>This function calculates the order of a matrix. <em>mat</em> must be a non-singular, square matrix. Even if <em>mat</em> is non-singular, the function may fail. This happens if the order is greater than 1000000, or if the order on any cyclic subspace is greater than 1000. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Pointer to the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The order of <em>mat</em>, or 1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1f99f1d8df6029caa43024f35e5c76e2"></a><!-- doxytag: member="matpivot.c::MatPivotize" ref="ga1f99f1d8df6029caa43024f35e5c76e2" args="(Matrix_t *mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MatPivotize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reduce to echelon form. </p>
<p>This function builds the pivot table of a matrix. Unlike <a class="el" href="group__mat.html#ga940fd894c097143d7a3dfc758a6dc32a" title="Reduce to echelon form This function performs a Gaussian elimination on the matrix |mat|...">MatEchelonize()</a> this function assumes that <em>mat</em> is already in echelon form. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Pointer to the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8e15736c076f1502120930c5cda593a0"></a><!-- doxytag: member="matpwr.c::MatPower" ref="ga8e15736c076f1502120930c5cda593a0" args="(const Matrix_t *mat, long n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMatrix__t.html">Matrix_t</a>* MatPower </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>!section obj.mat Power of a matrix. </p>
<p>!synopsis <a class="el" href="structMatrix__t.html" title="A matrix over a finite field.">Matrix_t</a> *MatPower(const <a class="el" href="structMatrix__t.html" title="A matrix over a finite field.">Matrix_t</a> *mat, long n); </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Pointer to the matrix. </td></tr>
    <tr><td class="paramname">n</td><td>Exponent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>|n|-th power of |mat|, or |NULL| on error. !description This function calculates the $n$-th power of a matrix, using the binary method. This method is generally faster than multiplying the matrix $n$ times by itself. On the other hand, a third matrix is temporarily created in addition to the original matrix and the result matrix. The cases $n=0$ and $n=1$ are handled separately, avoiding unnecessary memory allocation and calculation.</dd></dl>
<p>Negative exponents are not allowed. To calculate a negative power, you must first invert the matrix with |MatInverse()| and then call |MatPower()| with the inverted matrix and a positive exponent. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__mat.html#gab9718111f7c42fe1d0af862b1073d70f" title="Multiply matrices This function multiplies dest from the right by src.">MatMul</a> <a class="el" href="group__mat.html#gad558823c4f5d656143d4164838e7a2c3" title="Inverse of a matrix This function calculates the inverse of a matrix.">MatInverse</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga375192f076aa6b5affbe996c7bd65485"></a><!-- doxytag: member="matprint.c::MatPrint" ref="ga375192f076aa6b5affbe996c7bd65485" args="(const char *name, const Matrix_t *m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatPrint </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print a Matrix on stdout. </p>
<p>This function prints a matrix on the standard output in readable form. If <em>name</em> is not 0, the name followed by an equal sign is printed before the matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name to print before the matrix, or 0. </td></tr>
    <tr><td class="paramname">m</td><td>Pointer to the matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga09bbc8fd9eef53f4691578717bea1ef3"></a><!-- doxytag: member="matread.c::MatRead" ref="ga09bbc8fd9eef53f4691578717bea1ef3" args="(FILE *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMatrix__t.html">Matrix_t</a>* MatRead </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a matrix from a file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>File to read from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the matrix, or 0 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="gab3a78cc293a56e9b73a8c6b3d5254f4c"></a><!-- doxytag: member="matwrite.c::MatSave" ref="gab3a78cc293a56e9b73a8c6b3d5254f4c" args="(const Matrix_t *mat, const char *fn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MatSave </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a matrix to a file. </p>
<p>This function opens a file, writes a matrix to the file, and closes the file. If a file with the specified name already exists, the old contents of the file are destroyd. To write more than one matrix to a file, use <a class="el" href="group__mat.html#gac61c071f417d0685dbcb8fe444feebca" title="Write a matrix to a file.">MatWrite()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Pointer to the matrix. </td></tr>
    <tr><td class="paramname">fn</td><td>File name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="gacc7e0fce362468e1a89dbfec4776d48f"></a><!-- doxytag: member="mattrace.c::MatTrace" ref="gacc7e0fce362468e1a89dbfec4776d48f" args="(const Matrix_t *mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ff.html#ga7aa199c0a6bba46562519780595ee2f3">FEL</a> MatTrace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Trace of a Matrix. </p>
<p>This function calculates the sum of all diagonal elements of a matrix. Note that the matrix need not be square. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Pointer to the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Trace of <em>mat</em>, <code>FF_ZERO</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7a2edca3247137c7a04df74017819241"></a><!-- doxytag: member="mattr.c::MatTransposed" ref="ga7a2edca3247137c7a04df74017819241" args="(const Matrix_t *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMatrix__t.html">Matrix_t</a>* MatTransposed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transpose a matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Pointer to the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the transposed matrix or 0 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="gac61c071f417d0685dbcb8fe444feebca"></a><!-- doxytag: member="matwrite.c::MatWrite" ref="gac61c071f417d0685dbcb8fe444feebca" args="(const Matrix_t *mat, FILE *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MatWrite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a matrix to a file. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__mat.html#gab3a78cc293a56e9b73a8c6b3d5254f4c" title="Write a matrix to a file.">MatSave</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Pointer to the matrix. </td></tr>
    <tr><td class="paramname">f</td><td>Pointer to the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on error. </dd></dl>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
<hr size="1"><address style="text-align: right;"><small>
MeatAxe 2.4 documentation, generated on Mon Nov 28 2011 22:17:18</small></address>
</body>
</html>
