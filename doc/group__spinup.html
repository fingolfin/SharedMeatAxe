<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MeatAxe: Spin-up and Split</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MeatAxe&#160;<span id="projectnumber">2.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group__spinup.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Spin-up and Split</div>  </div>
</div>
<div class="contents">
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Spin-Up</b></dt><dd>Given a matrix representation and a seed vector v, the spin-up algorithm calculates the submodule generated by the seed vector, i.e., the smallest subspace containing v which is invariant under the generators. <a class="el" href="group__spinup.html#gac799ac27e88032c25abd53cec82dfec6" title="Spin up.">SpinUp()</a> can handle multiple seed vectors, search for cyclic vectors generating the whole space, and generate seed vectors as linear combinations of a given basis.</dd></dl>
<dl class="user"><dt><b>Spin-up Scripts</b></dt><dd>When spinning up a seed vector, you can record the operations performed by the algorithm in a spin-up script. This script can then be fed into <a class="el" href="group__spinup.html#ga0c307bb0e80c0de02160d705c7e7ae90" title="Spin-up with script.">SpinUpWithScript()</a> to repeat the procedure with a different seed vector and different generators.</dd></dl>
<dl class="user"><dt><b>Standard Basis</b></dt><dd>Normally, the basis vectors computed during the spin-up process are chosen randomly. However, the spin-up algorithm can be used in "standard basis" mode. In this mode, the result is invariant under a change of basis. More precisely, if a given seed vector v and generators g<sub>1</sub>,...g<sub>n</sub> produce the basis (b<sub>1</sub>,...b_<sub>m</sub>), and A is a nonsingular matrix, then vA and A<sup>-1</sup>g<sub>1</sub>A,...A<sup>-1</sup>g<sub>n</sub>A produce the basis (b<sub>1</sub>A,...b<sub>m</sub>A).</dd></dl>
<dl class="user"><dt><b>Splitting a Representation</b></dt><dd>If a proper invariant subspace U&lt;V has been found for a matrix representation M, the restriction of M to U as well as the representation on V/U can be calculated. This is called splitting the representation. Note that the representation on V/U depends on a randomly chosen basis. </dd></dl>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSpinUpInfo__t.html">SpinUpInfo_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Spin-up Parameters.  <a href="structSpinUpInfo__t.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spinup.html#gaf7d5c685345c6154e892347d6301489a">QProjection</a> (const <a class="el" href="structMatrix__t.html">Matrix_t</a> *subspace, const <a class="el" href="structMatrix__t.html">Matrix_t</a> *vectors)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Projection on Quotient.  <a href="#gaf7d5c685345c6154e892347d6301489a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spinup.html#ga8b3cdad9ad1587b8ef9249d1bf309958">QAction</a> (const <a class="el" href="structMatrix__t.html">Matrix_t</a> *subspace, const <a class="el" href="structMatrix__t.html">Matrix_t</a> *gen)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Action on Quotient.  <a href="#ga8b3cdad9ad1587b8ef9249d1bf309958"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spinup.html#ga6453d52c1ab786133f3599c8d2ca3e18">SAction</a> (const <a class="el" href="structMatrix__t.html">Matrix_t</a> *subspace, const <a class="el" href="structMatrix__t.html">Matrix_t</a> *gen)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Action on a subspace.  <a href="#ga6453d52c1ab786133f3599c8d2ca3e18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spinup.html#gac799ac27e88032c25abd53cec82dfec6">SpinUp</a> (const <a class="el" href="structMatrix__t.html">Matrix_t</a> *seed, const <a class="el" href="structMatRep__t.html">MatRep_t</a> *rep, int flags, <a class="el" href="structIntMatrix__t.html">IntMatrix_t</a> **script, <a class="el" href="structSpinUpInfo__t.html">SpinUpInfo_t</a> *info)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Spin up.  <a href="#gac799ac27e88032c25abd53cec82dfec6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spinup.html#ga080b840e2f35bd41a14b2fe6f83164c7">SpinUpWithPermutations</a> (const <a class="el" href="structMatrix__t.html">Matrix_t</a> *seed, int ngen, const <a class="el" href="structPerm__t.html">Perm_t</a> **gen, int flags, <a class="el" href="structIntMatrix__t.html">IntMatrix_t</a> **script, <a class="el" href="structSpinUpInfo__t.html">SpinUpInfo_t</a> *info)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Spin Up With Permutations.  <a href="#ga080b840e2f35bd41a14b2fe6f83164c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spinup.html#ga13a716de679d5e0dcca7f2ebb79002fa">SpinUpInfoInit</a> (<a class="el" href="structSpinUpInfo__t.html">SpinUpInfo_t</a> *info)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize spin-up parameters.  <a href="#ga13a716de679d5e0dcca7f2ebb79002fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spinup.html#ga0c307bb0e80c0de02160d705c7e7ae90">SpinUpWithScript</a> (const <a class="el" href="structMatrix__t.html">Matrix_t</a> *seed, const <a class="el" href="structMatRep__t.html">MatRep_t</a> *rep, const <a class="el" href="structIntMatrix__t.html">IntMatrix_t</a> *script)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Spin-up with script.  <a href="#ga0c307bb0e80c0de02160d705c7e7ae90"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spinup.html#gafba7d799c52cb6191cdecb6fecddf460">Split</a> (<a class="el" href="structMatrix__t.html">Matrix_t</a> *subspace, const <a class="el" href="structMatRep__t.html">MatRep_t</a> *rep, <a class="el" href="structMatRep__t.html">MatRep_t</a> **sub, <a class="el" href="structMatRep__t.html">MatRep_t</a> **quot)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a Representation.  <a href="#gafba7d799c52cb6191cdecb6fecddf460"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga8b3cdad9ad1587b8ef9249d1bf309958"></a><!-- doxytag: member="quotient.c::QAction" ref="ga8b3cdad9ad1587b8ef9249d1bf309958" args="(const Matrix_t *subspace, const Matrix_t *gen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMatrix__t.html">Matrix_t</a>* QAction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>subspace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Action on Quotient. </p>
<p>Given a subspace U≤F<sup>n</sup> and a matrix A∊F<sup>n×n</sup> that maps U into U, this function calculates the action of the matrix on the quotient F<sup>n</sup>/U. As input, the function expects a basis of the subspace in <em>subspace</em>, which must be in echelon form, and the matrix operating on the subspace in <em>gen</em>. The result is a square matrix with n-dim(U) rows describing the action of A on the quotient in a randomly chosen basis.</p>
<p>Before calculating the action, <a class="el" href="group__spinup.html#ga8b3cdad9ad1587b8ef9249d1bf309958" title="Action on Quotient.">QAction()</a> checks if the arguments are valid matrices, and if they are compatible. Both <em>subspace</em> and <em>gen</em> must be over the same field, have the same number of columns, and <em>gen</em> must be square.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">subspace</td><td>Pointer to an invariant subspace. </td></tr>
    <tr><td class="paramname">gen</td><td>Matrix operating on the subspace. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Action of the generator on the quotient, or 0 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf7d5c685345c6154e892347d6301489a"></a><!-- doxytag: member="quotient.c::QProjection" ref="gaf7d5c685345c6154e892347d6301489a" args="(const Matrix_t *subspace, const Matrix_t *vectors)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMatrix__t.html">Matrix_t</a>* QProjection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>subspace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>vectors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Projection on Quotient. </p>
<p>This function calculates the projection of a matrix onto the quotient by a subspace. The first matrix, <em>subspace</em> must be in echelon form, while the second argument can be any matrix. Of course both matrices must be over the same field and have the same number of columns. The return value is a pointer to a matrix containing the projections the <em>vectors</em>. This matrix is not in echelon form and may even contain null rows.</p>
<p>The projection depends on the basis for the subspace and is calculated as follows. Let V=F<sup>n×n</sup> and (w<sub>1</sub>,...w<sub>s</sub>) be a basis for the subspace W≤V. The basis, written as a matrix of row vectors, is assumed to be in semi-echelon form. By looking at the pivot columns we can construct the vectors w<sub>s+1</sub>,...w<sub>n</sub> by taking all vectors which have a exactly one 1 at any non-pivot position and are zero otherwise. Then, (w<sub>1</sub>,...,w<sub>s</sub>,w<sub>s+1</sub>,...,w<sub>n</sub>) is a basis for V in semi-echelon form and defines the decomposition of any vector into subspace and quotient part.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">subspace</td><td>The invariant subspace. </td></tr>
    <tr><td class="paramname">vectors</td><td>The vectors to project. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Projection of <em>vectors</em> on the quotient by <em>subspace</em>, or 0 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6453d52c1ab786133f3599c8d2ca3e18"></a><!-- doxytag: member="saction.c::SAction" ref="ga6453d52c1ab786133f3599c8d2ca3e18" args="(const Matrix_t *subspace, const Matrix_t *gen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMatrix__t.html">Matrix_t</a>* SAction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>subspace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Action on a subspace. </p>
<p>Given a subspace U≤F<sup>n</sup> and a matrix A∊F<sup>n×n</sup> that maps U into U, this function calculates the action of the matrix on the subspace. As input, the function expects a basis of the subspace in <em>subspace</em>, which must be in chelon form, and the matrix operating on the subspace in <em>gen</em>. The result is a square matrix with dim(U) rows containing the image of the basis vectors under A, expressed in the given basis.</p>
<p>Before calculating the action, <a class="el" href="group__spinup.html#ga6453d52c1ab786133f3599c8d2ca3e18" title="Action on a subspace.">SAction()</a> checks if the arguments are valid matrices, and if they are compatible. Both <em>subspace</em> and <em>gen</em> must be over the same field, have the same number of columns, and <em>gen</em> must be square.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">subspace</td><td>Pointer to an invariant subspace. </td></tr>
    <tr><td class="paramname">gen</td><td>Matrix operating on the subspace. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Action of the generator on the subspace, or 0 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="gac799ac27e88032c25abd53cec82dfec6"></a><!-- doxytag: member="spinup.c::SpinUp" ref="gac799ac27e88032c25abd53cec82dfec6" args="(const Matrix_t *seed, const MatRep_t *rep, int flags, IntMatrix_t **script, SpinUpInfo_t *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMatrix__t.html">Matrix_t</a>* SpinUp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatRep__t.html">MatRep_t</a> *&#160;</td>
          <td class="paramname"><em>rep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structIntMatrix__t.html">IntMatrix_t</a> **&#160;</td>
          <td class="paramname"><em>script</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSpinUpInfo__t.html">SpinUpInfo_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Spin up. </p>
<p>This function calculates the submodule generated by one or more "seed" vectors under the action of a set of matrices. <em>seed</em> must be a matrix with the same number of columns as the generators and any number of rows. Of course, all matrices, generators and seed, must be over the same field.</p>
<p>The spinup mode and various options are controlled by two arguments, <em>flags</em> and <em>info</em>. <em>flags</em> must be a combination of the following values:</p>
<ul>
<li><code>SF_FIRST:</code> Only the first row of <em>seed</em> is taken as seed vector.</li>
<li><code>SF_EACH:</code> Each row of <em>seed</em> is taken as seed vector.</li>
<li><code>SF_MAKE:</code> One vector from each 1-dimensional subspace of the row space of <em>seed</em> is taken as seed vector.</li>
<li><code>SF_SUB:</code> Find a submodule: spin up seed vectors one-by-one until a seed vector generates a proper submodule.</li>
<li><code>SF_CYCLIC:</code> Find a cyclic vector: spin up vectors one-by-one until a seed vector generates the whole space.</li>
<li><code>SF_COMBINE:</code> Calculate the submodule generated by the set of all seed vectors. This ist typically used with <code>SF_EACH</code> to calculate the submodule generate by the row space of <em>seed</em>.</li>
<li><code>SF_STD:</code> Create the standard basis. This increases both computation time and memory usage.</li>
</ul>
<p>The seed modes, <code>SF_FIRST</code>, <code>SF_EACH</code> and <code>SF_MAKE</code>, and the search modes, <code>SF_SUB</code>, <code>SF_CYCLIC</code>, <code>SF_COMBINE</code>, are mutually exclusive. If, in mode <code>SF_SUB</code> or <code>SF_CYCLIC</code>, no seed vector generates a proper submodule or the whole space, respectively, this is not considered an error, and the return value is not <code>NULL</code>. The rows of the matrix returned by <a class="el" href="group__spinup.html#gac799ac27e88032c25abd53cec82dfec6" title="Spin up.">SpinUp()</a> always form a basis of an invariant subspace, but you must examine the number of rows of that matrix to find out if it is a proper subspace, or null, or the whole space.</p>
<p>The subspace returned by <a class="el" href="group__spinup.html#gac799ac27e88032c25abd53cec82dfec6" title="Spin up.">SpinUp()</a> is always in echelon form, if <code>SF_STD</code> is not used. With <code>SF_STD</code> however, the subspace is not necessarily in echelon form.</p>
<p><a class="el" href="group__spinup.html#gac799ac27e88032c25abd53cec82dfec6" title="Spin up.">SpinUp()</a> can record the operations that led to the invariant subspace in a "spin-up script". You can use the script as input to <a class="el" href="group__spinup.html#ga0c307bb0e80c0de02160d705c7e7ae90" title="Spin-up with script.">SpinUpWithScript()</a> to repeat the spin-up with a different seed vector. Typically, a spin-up script is created together with <em>SF_STD</em>, and then used to reconstruct the standard basis in a different representation. In order to create a spin-up script, <em>script</em> must point to a variable of type IntMatrix_t*. This variable must either be 0 or contain a valid pointer. In the second case, the buffer pointed to by <em>script</em> is first deallocated before a new script is created. After <a class="el" href="group__spinup.html#gac799ac27e88032c25abd53cec82dfec6" title="Spin up.">SpinUp()</a> returns, the variable contains a pointer to the script. If no spinup script is needed, pass 0 as 4th parameter.</p>
<p>The format of the spinup script is a matrix with 2 columns and one row for each basis vector. A row (n,-1) means that the corresponding basis vector is the n-th seed vector. Seed vector numbers start from 1. An entry (n,g) with g≥0 means that the corresponding basis vector was obtained by multiplying the n-th basis vector by the g-th generator. Basis vector number and generator number start from 0.</p>
<p>Additional parameters can be passed via the <em>info</em> argument. To be compatible with future versions of <a class="el" href="structSpinUpInfo__t.html" title="Spin-up Parameters.">SpinUpInfo_t</a>, you should always initialize the parameter structure with SpinUpinfoInit().</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>Matrix with seed vectors. </td></tr>
    <tr><td class="paramname">rep</td><td>Pointer to a <a class="el" href="structMatRep__t.html" title="A matrix representation.">MatRep_t</a> structure with generators. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags, a combination of <code>SF_XXXX</code> constants (see description). </td></tr>
    <tr><td class="paramname">script</td><td>Pointer to a variable where the spinup script will be stored (see description). May be 0. </td></tr>
    <tr><td class="paramname">info</td><td>Pointer to a data structure with additional parameters, or 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Span of the seed vector(s) under the action of the generators, or 0 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga13a716de679d5e0dcca7f2ebb79002fa"></a><!-- doxytag: member="spinup.c::SpinUpInfoInit" ref="ga13a716de679d5e0dcca7f2ebb79002fa" args="(SpinUpInfo_t *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SpinUpInfoInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSpinUpInfo__t.html">SpinUpInfo_t</a> *&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize spin-up parameters. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>Pointer to parameter structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga080b840e2f35bd41a14b2fe6f83164c7"></a><!-- doxytag: member="spinup.c::SpinUpWithPermutations" ref="ga080b840e2f35bd41a14b2fe6f83164c7" args="(const Matrix_t *seed, int ngen, const Perm_t **gen, int flags, IntMatrix_t **script, SpinUpInfo_t *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMatrix__t.html">Matrix_t</a>* SpinUpWithPermutations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ngen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPerm__t.html">Perm_t</a> **&#160;</td>
          <td class="paramname"><em>gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structIntMatrix__t.html">IntMatrix_t</a> **&#160;</td>
          <td class="paramname"><em>script</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSpinUpInfo__t.html">SpinUpInfo_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Spin Up With Permutations. </p>
<p>This function works like Spinup() but expects permutations instead of matrices for the generators. </p>

</div>
</div>
<a class="anchor" id="ga0c307bb0e80c0de02160d705c7e7ae90"></a><!-- doxytag: member="spinup2.c::SpinUpWithScript" ref="ga0c307bb0e80c0de02160d705c7e7ae90" args="(const Matrix_t *seed, const MatRep_t *rep, const IntMatrix_t *script)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMatrix__t.html">Matrix_t</a>* SpinUpWithScript </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatRep__t.html">MatRep_t</a> *&#160;</td>
          <td class="paramname"><em>rep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structIntMatrix__t.html">IntMatrix_t</a> *&#160;</td>
          <td class="paramname"><em>script</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Spin-up with script. </p>
<p>This function repeats a previous spin-up with different seed vector and generators. Todo so, the functino needs a spin-up script, which is generated by <a class="el" href="group__spinup.html#gac799ac27e88032c25abd53cec82dfec6" title="Spin up.">SpinUp()</a>. The result is a matrix having as many rows as the script. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>Matrix with seed vectors. </td></tr>
    <tr><td class="paramname">rep</td><td>Pointer to a <a class="el" href="structMatRep__t.html" title="A matrix representation.">MatRep_t</a> structure with generators. </td></tr>
    <tr><td class="paramname">script</td><td>Pointer to the spinup script. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Span of the seed vector(s) under the action of the generators, or 0 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="gafba7d799c52cb6191cdecb6fecddf460"></a><!-- doxytag: member="split.c::Split" ref="gafba7d799c52cb6191cdecb6fecddf460" args="(Matrix_t *subspace, const MatRep_t *rep, MatRep_t **sub, MatRep_t **quot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>subspace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatRep__t.html">MatRep_t</a> *&#160;</td>
          <td class="paramname"><em>rep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMatRep__t.html">MatRep_t</a> **&#160;</td>
          <td class="paramname"><em>sub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMatRep__t.html">MatRep_t</a> **&#160;</td>
          <td class="paramname"><em>quot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Split a Representation. </p>
<p>Given a matrix representation of an algebra A and an A-invariant subspace U, this function calculates two new matrix representations corrsponding to the subspace and quotient, respectively.</p>
<p><em>subspace</em> is a basis for the invariant subspace. This matrix must be in echelon form. <em>rep</em> is the representation to be split. <em>sub</em> and <em>quot</em> are pointers to variables, where the representation on subspace and quotient, respectively, will be stored. Both <em>sub</em> and <em>quot</em> can be 0 if the corresponding representation is not needed. If <em>sub</em> is not 0, <code>*sub</code> must be 0 or a pointer to a valid matrix representation, which will be destroyed before the result is stored in <em>*sub|</em>. The same remark applies to <em>quot</em>.</p>
<p>The function checks that the subspace is indeed invariant under the given representation. However, this check is carried out only when the subspace is calculated, i.e., if <em>sub</em> is not 0. The function also check if subspace and representation are compatible. If any of these checks fails, the return value is -1.</p>
<p>Internally, <a class="el" href="group__spinup.html#gafba7d799c52cb6191cdecb6fecddf460" title="Split a Representation.">Split()</a> uses <a class="el" href="group__spinup.html#ga6453d52c1ab786133f3599c8d2ca3e18" title="Action on a subspace.">SAction()</a> and <a class="el" href="group__spinup.html#ga8b3cdad9ad1587b8ef9249d1bf309958" title="Action on Quotient.">QAction()</a> to calculate the action of the generators on the subspace and quotient.</p>
<p>The following examples shows how to use <a class="el" href="group__spinup.html#gac799ac27e88032c25abd53cec82dfec6" title="Spin up.">SpinUp()</a> to find an invariant subspace. If a proper subspace is found, the representation is split using <a class="el" href="group__spinup.html#gafba7d799c52cb6191cdecb6fecddf460" title="Split a Representation.">Split()</a>: </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="structMatRep__t.html" title="A matrix representation.">MatRep_t</a> *Rep;
 <a class="code" href="structMatrix__t.html" title="A matrix over a finite field.">Matrix_t</a> *seed;
 <a class="code" href="structMatrix__t.html" title="A matrix over a finite field.">Matrix_t</a> *subspace;
 ...
 subspace = <a class="code" href="group__spinup.html#gac799ac27e88032c25abd53cec82dfec6" title="Spin up.">SpinUp</a>(seed,Rep,SF_FIRST|SF_SUB);
 <span class="keywordflow">if</span> (subspace-&gt;<a class="code" href="structMatrix__t.html#a8a5efd601eee9ddd3ef4f1cd9e751b6d" title="Number of rows.">Nor</a> &gt; 0 &amp;&amp; subspace-&gt;<a class="code" href="structMatrix__t.html#a8a5efd601eee9ddd3ef4f1cd9e751b6d" title="Number of rows.">Nor</a> &lt; subspace-&gt;<a class="code" href="structMatrix__t.html#a90d6177cc3938028fffe2cfd35a850f9" title="Number of columns.">Noc</a>)
 {
     <a class="code" href="structMatRep__t.html" title="A matrix representation.">MatRep_t</a> *Sub = NULL, *Quot = NULL;
     printf(<span class="stringliteral">&quot;Split!\n&quot;</span>);
     <a class="code" href="group__spinup.html#gafba7d799c52cb6191cdecb6fecddf460" title="Split a Representation.">Split</a>(subspace,Rep,&amp;Sub,&amp;Quot);
 }
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__spinup.html#gac799ac27e88032c25abd53cec82dfec6" title="Spin up.">SpinUp</a> <a class="el" href="group__spinup.html#ga8b3cdad9ad1587b8ef9249d1bf309958" title="Action on Quotient.">QAction</a> <a class="el" href="group__spinup.html#ga6453d52c1ab786133f3599c8d2ca3e18" title="Action on a subspace.">SAction</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">subspace</td><td>Pointer to an invariant subspace. </td></tr>
    <tr><td class="paramname">rep</td><td>Matrix representation to split. </td></tr>
    <tr><td class="paramname">sub</td><td>Matrix representation on the subspace. </td></tr>
    <tr><td class="paramname">quot</td><td>Matrix representation on the quotient. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on error. </dd></dl>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
<hr size="1"><address style="text-align: right;"><small>
MeatAxe 2.4 documentation, generated on Mon Nov 28 2011 22:17:18</small></address>
</body>
</html>
