<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MeatAxe: Text File Handling</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MeatAxe&#160;<span id="projectnumber">2.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group__stf.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Text File Handling</div>  </div>
</div>
<div class="contents">
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>The MeatAxe library provides functions for input and output of data in human-readable text format. </p>
<p>Files that are created with this set of functions have a defined structure, and are refered to as "structured text files" (STF). An examples for this type of files is the .cfinfo file which is used by the submodule lattice programs.</p>
<h2><a class="anchor" id="filefmt"></a>
File format</h2>
<p>A structured text file is interpreted as a sequence of lines. While the STF input functions can read very long lines, the output functions try to limit the line length to 80 characters in order to make the file more readable. Each line is one of the following:</p>
<ul>
<li>Lines starting with a "#" in column 1 are comment lines and are ignored completely. Empty lines are ignored, too.</li>
<li>A non-comment line with a non-blank character in column 1 marks the beginning of a new entry. Such a line has the format <div class="fragment"><pre class="fragment"> Name := Value
</pre></div> Both <em>Name</em> and <em>Value</em> are arbitrary strings, except that they cannot contain leading or trailing blanks. In fact leading and trailing blanks as well as any blanks around the ":=" are removed on input.</li>
<li>Lines starting with a whitspace character are interpreted as continuing lines. Obviously a continuing line may occur only after an entry has started. The contents of the continuing line, after leading lanks have been removed, are appended to <em>Value</em>.</li>
</ul>
<h2><a class="anchor" id="datafmt"></a>
Data formats</h2>
<p>Besides the removal of leading and trailing blanks there is no restriction on the format of </p>
<p>in an STF entry. There are, however, predefined functions that read and write integers and sequences of integers. An application should use these functions where possible. The format used by the integer i/o functions is most easily demonstrated in an example: </p>
<pre>
 Field := 7;
 Multiplicity := [1,1,1,2];
 Dimensions := [11,22,33,44,55];
 </pre><p> The format has been chosen such that GAP can read the text file without modification. </p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stf.html#ga72c3c61ad2f0c722a4efd683d64a1b0b">StfClose</a> (<a class="el" href="structStfData.html">StfData</a> *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a Structured Text File.  <a href="#ga72c3c61ad2f0c722a4efd683d64a1b0b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structStfData.html">StfData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stf.html#ga8f928187e433aff6028abd71b5e258d2">StfOpen</a> (const char *name, int mode)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a Structured Text File.  <a href="#ga8f928187e433aff6028abd71b5e258d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stf.html#gaf33d64f31aa949791aec5323ed664d94">StfReadLine</a> (<a class="el" href="structStfData.html">StfData</a> *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Next Line.  <a href="#gaf33d64f31aa949791aec5323ed664d94"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stf.html#gac454624d144c5030c5df95d00992b17c">StfGetName</a> (<a class="el" href="structStfData.html">StfData</a> *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Entry Name.  <a href="#gac454624d144c5030c5df95d00992b17c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stf.html#gacae5ca04ddec2b04d03197245fb0e46a">StfGetInt</a> (<a class="el" href="structStfData.html">StfData</a> *f, int *buf)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an Integer.  <a href="#gacae5ca04ddec2b04d03197245fb0e46a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stf.html#ga671e00105b070d52a2fbee08cc1614c5">StfGetString</a> (<a class="el" href="structStfData.html">StfData</a> *f, char *buf, size_t bufsize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a string.  <a href="#ga671e00105b070d52a2fbee08cc1614c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stf.html#ga50a13c2223fdd3b3ceef067d9de1dd63">StfMatch</a> (<a class="el" href="structStfData.html">StfData</a> *f, const char *pattern)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip text.  <a href="#ga50a13c2223fdd3b3ceef067d9de1dd63"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stf.html#ga91387f2a327ffd2fffc5adc8d0efbb58">StfGetVector</a> (<a class="el" href="structStfData.html">StfData</a> *f, int *bufsize, int *buf)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a vector.  <a href="#ga91387f2a327ffd2fffc5adc8d0efbb58"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga98ac6553e32e8dfbcf3e81e80d9516ae"></a><!-- doxytag: member="stf::StfPut" ref="ga98ac6553e32e8dfbcf3e81e80d9516ae" args="(StfData *f, const char *text)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stf.html#ga98ac6553e32e8dfbcf3e81e80d9516ae">StfPut</a> (<a class="el" href="structStfData.html">StfData</a> *f, const char *text)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a Raw Value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacb89175605caf1f9c08dec4dcadb569a"></a><!-- doxytag: member="stf::StfPutInt" ref="gacb89175605caf1f9c08dec4dcadb569a" args="(StfData *f, int value)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stf.html#gacb89175605caf1f9c08dec4dcadb569a">StfPutInt</a> (<a class="el" href="structStfData.html">StfData</a> *f, int value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an Integer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae1531f18eb565a1d3db1da4c2b55f6b7"></a><!-- doxytag: member="stf::StfPutString" ref="gae1531f18eb565a1d3db1da4c2b55f6b7" args="(StfData *f, const char *text)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stf.html#gae1531f18eb565a1d3db1da4c2b55f6b7">StfPutString</a> (<a class="el" href="structStfData.html">StfData</a> *f, const char *text)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a <a class="el" href="structString.html" title="A dynamic string.">String</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1fee60a1c80fc0a9177c13ac6b0c2099"></a><!-- doxytag: member="stf::StfPutVector" ref="ga1fee60a1c80fc0a9177c13ac6b0c2099" args="(StfData *f, int size, const int *value)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stf.html#ga1fee60a1c80fc0a9177c13ac6b0c2099">StfPutVector</a> (<a class="el" href="structStfData.html">StfData</a> *f, int size, const int *value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a Vector. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stf.html#gade11b9ba48a1c23475d168862ec82a3d">StfBeginEntry</a> (<a class="el" href="structStfData.html">StfData</a> *f, const char *name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a New Entry.  <a href="#gade11b9ba48a1c23475d168862ec82a3d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stf.html#ga3e26da787726a09b98ee2428abba3cf7">StfEndEntry</a> (<a class="el" href="structStfData.html">StfData</a> *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">End Entry.  <a href="#ga3e26da787726a09b98ee2428abba3cf7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stf.html#ga3851785ef394d4feb34784bec8a244eb">StfWriteValue</a> (<a class="el" href="structStfData.html">StfData</a> *f, const char *name, const char *value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a <a class="el" href="structString.html" title="A dynamic string.">String</a>.  <a href="#ga3851785ef394d4feb34784bec8a244eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stf.html#gaf3fba4db33c0571a5ef27dd48a3a9e5d">StfWriteString</a> (<a class="el" href="structStfData.html">StfData</a> *f, const char *name, const char *value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a <a class="el" href="structString.html" title="A dynamic string.">String</a>.  <a href="#gaf3fba4db33c0571a5ef27dd48a3a9e5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stf.html#ga2395278458ccc93b839989cb3be5e4fd">StfWriteInt</a> (<a class="el" href="structStfData.html">StfData</a> *f, const char *name, int value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an Integer.  <a href="#ga2395278458ccc93b839989cb3be5e4fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stf.html#gad71b3e21e1935b649b2ad183f957b038">StfWriteVector</a> (<a class="el" href="structStfData.html">StfData</a> *f, const char *name, int size, const int *value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a Vector.  <a href="#gad71b3e21e1935b649b2ad183f957b038"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gade11b9ba48a1c23475d168862ec82a3d"></a><!-- doxytag: member="stfwrite.c::StfBeginEntry" ref="gade11b9ba48a1c23475d168862ec82a3d" args="(StfData *f, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int StfBeginEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structStfData.html">StfData</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start a New Entry. </p>
<p>This function begins a new entry. Be sure to terminate any incomplete entries with <a class="el" href="group__stf.html#ga3e26da787726a09b98ee2428abba3cf7" title="End Entry.">StfEndEntry()</a> before you start a new entry. If you don't, the incomplete entry may be lost, and the data file may become corrupted.</p>
<p>Before you use StfBeginEntry(), check if you can do the job with one of the StfWriteXXX() functions. In particular, there are functions to write integers and sequences of integers. If you have more complicated data to write, you may need to construct the output manually. Here is an example: </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="group__stf.html#gade11b9ba48a1c23475d168862ec82a3d" title="Start a New Entry.">StfBeginEntry</a>(f,<span class="stringliteral">&quot;Param&quot;</span>);
 <a class="code" href="group__stf.html#ga98ac6553e32e8dfbcf3e81e80d9516ae" title="Write a Raw Value.">StfPut</a>(f,<span class="stringliteral">&quot;(&quot;</span>);
 <a class="code" href="group__stf.html#gacb89175605caf1f9c08dec4dcadb569a" title="Write an Integer.">StfPutInt</a>(f,11);
 <a class="code" href="group__stf.html#ga98ac6553e32e8dfbcf3e81e80d9516ae" title="Write a Raw Value.">StfPut</a>(f,<span class="stringliteral">&quot;:&quot;</span>);
 <a class="code" href="group__stf.html#gacb89175605caf1f9c08dec4dcadb569a" title="Write an Integer.">StfPutInt</a>(f,22);
 <a class="code" href="group__stf.html#ga98ac6553e32e8dfbcf3e81e80d9516ae" title="Write a Raw Value.">StfPut</a>(f,<span class="stringliteral">&quot;)&quot;</span>);
 <a class="code" href="group__stf.html#ga3e26da787726a09b98ee2428abba3cf7" title="End Entry.">StfEndEntry</a>(f);
</pre></div><p> This code produces the following line in the output <a href="file:">file:</a> </p>
<pre>
 Param := (11:22);
 </pre> <dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Pointer to a structured text file (STF) object. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga72c3c61ad2f0c722a4efd683d64a1b0b"></a><!-- doxytag: member="stfcore.c::StfClose" ref="ga72c3c61ad2f0c722a4efd683d64a1b0b" args="(StfData *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int StfClose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structStfData.html">StfData</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close a Structured Text File. </p>
<p>This function closes a structured text file. Closing the file implies that the memory occupied by the <a class="el" href="structStfData.html" title="Structured text file.">StfData</a> structure is freed. Thus, after return, <em>f</em> is invalid and must not be dereferenced. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Pointer to an open structured text file (STF) object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, non-zero on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3e26da787726a09b98ee2428abba3cf7"></a><!-- doxytag: member="stfwrite.c::StfEndEntry" ref="ga3e26da787726a09b98ee2428abba3cf7" args="(StfData *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int StfEndEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structStfData.html">StfData</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>End Entry. </p>
<p>This function terminates the current entry and flushes the STF's line buffer. See <a class="el" href="group__stf.html#gade11b9ba48a1c23475d168862ec82a3d" title="Start a New Entry.">StfBeginEntry()</a> for an example. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Pointer to a structured text file (STF) object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="gacae5ca04ddec2b04d03197245fb0e46a"></a><!-- doxytag: member="stfread.c::StfGetInt" ref="gacae5ca04ddec2b04d03197245fb0e46a" args="(StfData *f, int *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int StfGetInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structStfData.html">StfData</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read an Integer. </p>
<p>This function gets one integer from the current line and increments the read pointer accordingly. Before this function is called, a line must have been read with <a class="el" href="group__stf.html#gaf33d64f31aa949791aec5323ed664d94" title="Read Next Line.">StfReadLine()</a> and prepared with <a class="el" href="group__stf.html#gac454624d144c5030c5df95d00992b17c" title="Get Entry Name.">StfGetName()</a>.</p>
<p>Reading starts at the current position. Any leading blanks are skipped. On return, the new current position is the character following the last digit. If there is no integer to read, the current position is not changed, and the function returns -1.</p>
<p>Here is an example: </p>
<div class="fragment"><pre class="fragment"> StfFile *f = <a class="code" href="group__stf.html#ga8f928187e433aff6028abd71b5e258d2" title="Open a Structured Text File.">StfOpen</a>(<span class="stringliteral">&quot;test&quot;</span>,<span class="stringliteral">&quot;r&quot;</span>);
 <span class="keywordtype">int</span> dim, degree, result = 0;
 <span class="keywordflow">while</span> (result == 0 &amp;&amp; <a class="code" href="group__stf.html#gaf33d64f31aa949791aec5323ed664d94" title="Read Next Line.">StfReadLine</a>(f) == 0)
 {
     <span class="keywordtype">char</span> *name = <a class="code" href="group__stf.html#gac454624d144c5030c5df95d00992b17c" title="Get Entry Name.">StfGetName</a>(f);
     <span class="keywordflow">if</span> (!strcmp(name,<span class="stringliteral">&quot;Dimension&quot;</span>))
         result = <a class="code" href="group__stf.html#gacae5ca04ddec2b04d03197245fb0e46a" title="Read an Integer.">StfGetInt</a>(f,&amp;dim);
     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(name,<span class="stringliteral">&quot;Degree&quot;</span>))
         result = <a class="code" href="group__stf.html#gacae5ca04ddec2b04d03197245fb0e46a" title="Read an Integer.">StfGetInt</a>(f,&amp;degree);
 }
</pre></div><p> This code fragment opens a text file and reads two parameters, "Degree" and "Dimension", into the variables <code>degree</code> and <code>dim</code>, respectively. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Pointer to a structured text file (STF) object. </td></tr>
    <tr><td class="paramname">buf</td><td>Pointer to a buffer receiving the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="gac454624d144c5030c5df95d00992b17c"></a><!-- doxytag: member="stfread.c::StfGetName" ref="gac454624d144c5030c5df95d00992b17c" args="(StfData *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* StfGetName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structStfData.html">StfData</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get Entry Name. </p>
<p>This function extracts the name part of internal line buffer and prepares the buffer for further parsing with StfGetXXX() functions. On return, <code>f-&gt;GetPtr</code> points to the first non-space character after the ":=". StfGetName() can be called only after a line was successfully read with <a class="el" href="group__stf.html#gaf33d64f31aa949791aec5323ed664d94" title="Read Next Line.">StfReadLine()</a>. It must be called before any of the StfGetXXX() functions. See <a class="el" href="group__stf.html#gacae5ca04ddec2b04d03197245fb0e46a" title="Read an Integer.">StfGetInt()</a> for an example. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Pointer to a structured text file (STF) object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Name found in text line or |NULL| on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga671e00105b070d52a2fbee08cc1614c5"></a><!-- doxytag: member="stfread.c::StfGetString" ref="ga671e00105b070d52a2fbee08cc1614c5" args="(StfData *f, char *buf, size_t bufsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int StfGetString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structStfData.html">StfData</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a string. </p>
<p>This function gets a string from the current line and increments the read pointer accordingly. Before this function is called, a line must have been read with <a class="el" href="group__stf.html#gaf33d64f31aa949791aec5323ed664d94" title="Read Next Line.">StfReadLine()</a> and prepared with <a class="el" href="group__stf.html#gac454624d144c5030c5df95d00992b17c" title="Get Entry Name.">StfGetName()</a>. The string is expected at the current position of the test file and must be in C syntax, i.e., enclosed in double quotation marks. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Pointer to a structured text file (STF) object. </td></tr>
    <tr><td class="paramname">buf</td><td>Pointer to a buffer receiving the value. </td></tr>
    <tr><td class="paramname">bufsize</td><td>Buffer size in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga91387f2a327ffd2fffc5adc8d0efbb58"></a><!-- doxytag: member="stfread.c::StfGetVector" ref="ga91387f2a327ffd2fffc5adc8d0efbb58" args="(StfData *f, int *bufsize, int *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int StfGetVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structStfData.html">StfData</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>bufsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a vector. </p>
<p>This function reads a sequence of integers. The sequence must have been written with <a class="el" href="group__stf.html#gad71b3e21e1935b649b2ad183f957b038" title="Write a Vector.">StfWriteVector()</a> or at least in the same format.</p>
<p>Before using this function, a line must have been read with <a class="el" href="group__stf.html#gaf33d64f31aa949791aec5323ed664d94" title="Read Next Line.">StfReadLine()</a> and prepared with StfGetname(). Reading starts at the current position, i.e., at the first non-space character after the ":=", or at the first character that was not read by the previous StfGetXXX() or <a class="el" href="group__stf.html#ga50a13c2223fdd3b3ceef067d9de1dd63" title="Skip text.">StfMatch()</a>.</p>
<p>The caller must supply two buffers, the data buffer (<em>buf</em>) and an integer buffer (<em>bufsize</em>). When StfGetVector() is called, the variable pointed to by <em>bufsize</em> must contain the maximal number of integers that can be stored in <em>buf</em>. On successful return, the variable contains the number of integers that were actually stored, which may be smaller than the original value. If the vector is to long to fit into the user-supplied buffer, the function reads as many entries as possible and returns -1.</p>
<p>Here is an example: </p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">char</span> *name = <a class="code" href="group__stf.html#gac454624d144c5030c5df95d00992b17c" title="Get Entry Name.">StfGetName</a>(f);
 <span class="keywordflow">if</span> (!strcmp(name,<span class="stringliteral">&quot;Vector&quot;</span>))
 {
     <span class="keywordtype">int</span> vec[10];
     <span class="keywordtype">int</span> vecsize = 10;
     <a class="code" href="group__stf.html#ga91387f2a327ffd2fffc5adc8d0efbb58" title="Read a vector.">StfGetVector</a>(f,&amp;vecsize,vec);
     printf(<span class="stringliteral">&quot;%d elements read\n&quot;</span>,*vecsize);
 }
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Pointer to a structured text file (STF) object. </td></tr>
    <tr><td class="paramname">bufsize</td><td>Pointer to a variable containing the buffer size. On return, the variable contains the number of elements actually read. </td></tr>
    <tr><td class="paramname">buf</td><td>Pointer to a buffer receiving the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The function returns $0$ on success and $-1$ on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga50a13c2223fdd3b3ceef067d9de1dd63"></a><!-- doxytag: member="stfread.c::StfMatch" ref="ga50a13c2223fdd3b3ceef067d9de1dd63" args="(StfData *f, const char *pattern)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int StfMatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structStfData.html">StfData</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Skip text. </p>
<p>This function reads (and skips) the text given by <em>pattern</em>. Before using this function, a line must have been read with <a class="el" href="group__stf.html#gaf33d64f31aa949791aec5323ed664d94" title="Read Next Line.">StfReadLine()</a> and prepared with StfGetname(). Reading starts at the current position, i.e., at the first non-space character after the ":=", or at the first character that was not read by the previous StfGetXXX() or <a class="el" href="group__stf.html#ga50a13c2223fdd3b3ceef067d9de1dd63" title="Skip text.">StfMatch()</a>. A space in <em>pattern</em> matches any number (including 0) of spaces or tabs. Any other characters in <em>pattern</em> are matched one-to-one against the input line. If <em>pattern</em> is matched completely, the current position is updated to the character after the last matched character. Otherwise, the current position is not changed and the function returns -1. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Pointer to a structured text file (STF) object. </td></tr>
    <tr><td class="paramname">pattern</td><td>The text to be skipped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0, if the complete text in <em>pattern</em> has beed skipped. -1 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8f928187e433aff6028abd71b5e258d2"></a><!-- doxytag: member="stfcore.c::StfOpen" ref="ga8f928187e433aff6028abd71b5e258d2" args="(const char *name, int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structStfData.html">StfData</a>* StfOpen </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open a Structured Text File. </p>
<p>This function opens a structured text file. It returns to a <a class="el" href="structStfData.html" title="Structured text file.">StfData</a> structure which can be used with StfXXX() functions. <em>name</em> and <em>mode</em> have the same semantics as with <a class="el" href="group__os.html#ga7fcb1d88bc45137760162aa62dfa748a" title="Open a file.">SysFopen()</a>. If the mode contains <code>FM_CREATE</code>, a new file is created and opened for writing, for example with <a class="el" href="group__stf.html#ga2395278458ccc93b839989cb3be5e4fd" title="Write an Integer.">StfWriteInt()</a>. If a file with the specified name already exists, it is truncated to length zero. Otherwise, a new file is created.</p>
<p>The mode <em>FM_READ</em> opens the file for reading. If the file does not exist the function fails. FM_TEXT is always added implicitely to the mode. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>File name. </td></tr>
    <tr><td class="paramname">mode</td><td>Open mode (see description). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="structStfData.html" title="Structured text file.">StfData</a> structure or 0 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf33d64f31aa949791aec5323ed664d94"></a><!-- doxytag: member="stfread.c::StfReadLine" ref="gaf33d64f31aa949791aec5323ed664d94" args="(StfData *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int StfReadLine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structStfData.html">StfData</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read Next Line. </p>
<p>This function reads a single text line into the STF object's internal line buffer and prepares the text for parsing with StfGetXXX() functions. <a class="el" href="group__stf.html#gaf33d64f31aa949791aec5323ed664d94" title="Read Next Line.">StfReadLine()</a> strips comments and assembles multi-line texts into a single line. Thus, the application need not handle comments and multi-line texts. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Pointer to a structured text file (STF) object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on end-of-file or error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2395278458ccc93b839989cb3be5e4fd"></a><!-- doxytag: member="stfwrite.c::StfWriteInt" ref="ga2395278458ccc93b839989cb3be5e4fd" args="(StfData *f, const char *name, int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int StfWriteInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structStfData.html">StfData</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write an Integer. </p>
<p>This function writes an integer to a structured text file. For example, the statement </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="group__stf.html#ga2395278458ccc93b839989cb3be5e4fd" title="Write an Integer.">StfWriteInt</a>(f,<span class="stringliteral">&quot;Dimension&quot;</span>,42);
</pre></div><p> produces the following output line: </p>
<pre>
 Dimension := 42;
 </pre> <dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Pointer to a structured text file (STF) object. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the entry. </td></tr>
    <tr><td class="paramname">value</td><td>Value of the entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf3fba4db33c0571a5ef27dd48a3a9e5d"></a><!-- doxytag: member="stfwrite.c::StfWriteString" ref="gaf3fba4db33c0571a5ef27dd48a3a9e5d" args="(StfData *f, const char *name, const char *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int StfWriteString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structStfData.html">StfData</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a <a class="el" href="structString.html" title="A dynamic string.">String</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Pointer to a structured text file (STF) object. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the entry. </td></tr>
    <tr><td class="paramname">value</td><td><a class="el" href="structString.html" title="A dynamic string.">String</a> to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on error. This function writes an arbitrary string to a structured text file. For example, the statement <div class="fragment"><pre class="fragment"> <a class="code" href="group__stf.html#ga3851785ef394d4feb34784bec8a244eb" title="Write a String.">StfWriteValue</a>(f,<span class="stringliteral">&quot;Title&quot;</span>,<span class="stringliteral">&quot;This is a test &quot;</span>);
</pre></div> produces the following output line: <pre>
 Title := "This is a test ";
 </pre> Unlike StrWriteValue() this function preserves leading and trailing spaces. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3851785ef394d4feb34784bec8a244eb"></a><!-- doxytag: member="stfwrite.c::StfWriteValue" ref="ga3851785ef394d4feb34784bec8a244eb" args="(StfData *f, const char *name, const char *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int StfWriteValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structStfData.html">StfData</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a <a class="el" href="structString.html" title="A dynamic string.">String</a>. </p>
<p>This function writes an arbitrary text to a structured text file. For example, the statement </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="group__stf.html#ga3851785ef394d4feb34784bec8a244eb" title="Write a String.">StfWriteValue</a>(f,<span class="stringliteral">&quot;Note&quot;</span>,<span class="stringliteral">&quot;This is a note&quot;</span>);
</pre></div><p> produces the following output line: </p>
<pre>
 Note := This is a note;
 </pre><p> Note that any leading spaces in the value will be stripped off when reading the file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Pointer to a structured text file (STF) object. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the entry. </td></tr>
    <tr><td class="paramname">value</td><td>Value of the entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="gad71b3e21e1935b649b2ad183f957b038"></a><!-- doxytag: member="stfwrite.c::StfWriteVector" ref="gad71b3e21e1935b649b2ad183f957b038" args="(StfData *f, const char *name, int size, const int *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int StfWriteVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structStfData.html">StfData</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a Vector. </p>
<p>This function writes a sequence of integers to a structured text file. For example, the statement </p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">int</span> dims[5] = {11,22,33,44,55};
 <a class="code" href="group__stf.html#gad71b3e21e1935b649b2ad183f957b038" title="Write a Vector.">StfWriteVector</a>(f,<span class="stringliteral">&quot;Dimensions&quot;</span>,dims,5);
</pre></div><p> produces the following output line: </p>
<pre>
 Dimensions := [11,22,33,44,55];
 </pre> <dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Pointer to a structured text file (STF) object. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the entry. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the vector (number of entries, not bytes). </td></tr>
    <tr><td class="paramname">value</td><td>Pointer to the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The function returns $0$ on success and $-1$ on error. </dd></dl>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
<hr size="1"><address style="text-align: right;"><small>
MeatAxe 2.4 documentation, generated on Mon Nov 28 2011 22:17:18</small></address>
</body>
</html>
